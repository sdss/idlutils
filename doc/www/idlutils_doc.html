<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>IDL Help for IDLUTILS</TITLE>
</head>
 
<body>
<H1>IDL Help for IDLUTILS</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Tue Sep 26 13:06:34 2000.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#ANGDIDIS">ANGDIDIS</A>
<LI><A HREF="#ATV">ATV</A>
<LI><A HREF="#BSPLINE_BKPTS">BSPLINE_BKPTS</A>
<LI><A HREF="#BSPLINE_FIT">BSPLINE_FIT</A>
<LI><A HREF="#BSPLINE_ITERFIT">BSPLINE_ITERFIT</A>
<LI><A HREF="#BSPLINE_VALU">BSPLINE_VALU</A>
<LI><A HREF="#BVALU2D">BVALU2D</A>
<LI><A HREF="#CMPS_FORM">CMPS_FORM</A>
<LI><A HREF="#COMDIS">COMDIS</A>
<LI><A HREF="#CPBACKUP">CPBACKUP</A>
<LI><A HREF="#DCOMDISDZ">DCOMDISDZ</A>
<LI><A HREF="#DISPLAY">DISPLAY</A>
<LI><A HREF="#DJS_ANGLE_GROUP">DJS_ANGLE_GROUP</A>
<LI><A HREF="#DJS_ANGLE_MATCH">DJS_ANGLE_MATCH</A>
<LI><A HREF="#DJS_ANGLE_NMATCH">DJS_ANGLE_NMATCH</A>
<LI><A HREF="#DJS_ANGPOS">DJS_ANGPOS</A>
<LI><A HREF="#DJS_ANGSGN">DJS_ANGSGN</A>
<LI><A HREF="#DJS_ARROW">DJS_ARROW</A>
<LI><A HREF="#DJS_AVSIGCLIP">DJS_AVSIGCLIP</A>
<LI><A HREF="#DJS_AXIS">DJS_AXIS</A>
<LI><A HREF="#DJS_CEIL">DJS_CEIL</A>
<LI><A HREF="#DJS_CONTOURPTS">DJS_CONTOURPTS</A>
<LI><A HREF="#DJS_CORRELATE">DJS_CORRELATE</A>
<LI><A HREF="#DJS_DIFF_ANGLE">DJS_DIFF_ANGLE</A>
<LI><A HREF="#DJS_FLOOR">DJS_FLOOR</A>
<LI><A HREF="#DJS_HEX2BIN">DJS_HEX2BIN</A>
<LI><A HREF="#DJS_HEX2INT">DJS_HEX2INT</A>
<LI><A HREF="#DJS_ICOLOR">DJS_ICOLOR</A>
<LI><A HREF="#DJS_INT2BIN">DJS_INT2BIN</A>
<LI><A HREF="#DJS_ITERSTAT">DJS_ITERSTAT</A>
<LI><A HREF="#DJS_LAXISGEN">DJS_LAXISGEN</A>
<LI><A HREF="#DJS_LOCATE_FILE()">DJS_LOCATE_FILE()</A>
<LI><A HREF="#DJS_LOCKFILE">DJS_LOCKFILE</A>
<LI><A HREF="#DJS_MASKINTERP">DJS_MASKINTERP</A>
<LI><A HREF="#DJS_MEAN">DJS_MEAN</A>
<LI><A HREF="#DJS_MEDIAN">DJS_MEDIAN</A>
<LI><A HREF="#DJS_MODFITS">DJS_MODFITS</A>
<LI><A HREF="#DJS_OPLOT">DJS_OPLOT</A>
<LI><A HREF="#DJS_OPLOTERR">DJS_OPLOTERR</A>
<LI><A HREF="#DJS_PLOT">DJS_PLOT</A>
<LI><A HREF="#DJS_PLOTLIMITBOX">DJS_PLOTLIMITBOX</A>
<LI><A HREF="#DJS_POSMOD">DJS_POSMOD</A>
<LI><A HREF="#DJS_READCOL">DJS_READCOL</A>
<LI><A HREF="#DJS_READILINES()">DJS_READILINES()</A>
<LI><A HREF="#DJS_READLINES()">DJS_READLINES()</A>
<LI><A HREF="#DJS_READMANY">DJS_READMANY</A>
<LI><A HREF="#DJS_REJECT">DJS_REJECT</A>
<LI><A HREF="#DJS_SELECTLINES">DJS_SELECTLINES</A>
<LI><A HREF="#DJS_UNLOCKFILE">DJS_UNLOCKFILE</A>
<LI><A HREF="#DJS_XYOUTS">DJS_XYOUTS</A>
<LI><A HREF="#DOTPRODUCT_SPHERE">DOTPRODUCT_SPHERE</A>
<LI><A HREF="#DPROPDISDZ">DPROPDISDZ</A>
<LI><A HREF="#EFC2D">EFC2D</A>
<LI><A HREF="#EFCMN">EFCMN</A>
<LI><A HREF="#FILEANDPATH">FILEANDPATH</A>
<LI><A HREF="#FILL_BSPLINE">FILL_BSPLINE</A>
<LI><A HREF="#FINDBKPT">FINDBKPT</A>
<LI><A HREF="#FLOATCOMPRESS">FLOATCOMPRESS</A>
<LI><A HREF="#GAUSSPIX1D">GAUSSPIX1D</A>
<LI><A HREF="#IDLUTILS_VERSION">IDLUTILS_VERSION</A>
<LI><A HREF="#IMGEXP">IMGEXP</A>
<LI><A HREF="#IMGSCL">IMGSCL</A>
<LI><A HREF="#INTRV">INTRV</A>
<LI><A HREF="#LUMDIS">LUMDIS</A>
<LI><A HREF="#MODFITSCARD">MODFITSCARD</A>
<LI><A HREF="#POPULATE_IMAGE">POPULATE_IMAGE</A>
<LI><A HREF="#PROPMOTDIS">PROPMOTDIS</A>
<LI><A HREF="#QZAP.PRO">QZAP.PRO</A>
<LI><A HREF="#RMFILE">RMFILE</A>
<LI><A HREF="#SLATEC_BVALU">SLATEC_BVALU</A>
<LI><A HREF="#SLATEC_EFC">SLATEC_EFC</A>
<LI><A HREF="#SLATEC_SPLINEFIT">SLATEC_SPLINEFIT</A>
<LI><A HREF="#SPLOT">SPLOT</A>
<LI><A HREF="#STDEV">STDEV</A>
<LI><A HREF="#STRUCT_ADDTAGS">STRUCT_ADDTAGS</A>
<LI><A HREF="#STRUCT_APPEND">STRUCT_APPEND</A>
<LI><A HREF="#STR_SEP">STR_SEP</A>
<LI><A HREF="#TEXTOIDL[1]">TEXTOIDL[1]</A>
<LI><A HREF="#TEXTOIDL[2]">TEXTOIDL[2]</A>
<LI><A HREF="#TEXTOIDL_MATCHDELIM">TEXTOIDL_MATCHDELIM</A>
<LI><A HREF="#TEXTOIDL_NEXTTOK">TEXTOIDL_NEXTTOK</A>
<LI><A HREF="#TEXTOIDL_STRCNT">TEXTOIDL_STRCNT</A>
<LI><A HREF="#TEXTOIDL_STRTOK">TEXTOIDL_STRTOK</A>
<LI><A HREF="#TEXTOIDL_STRTRANS">TEXTOIDL_STRTRANS</A>
<LI><A HREF="#TEXTOIDL_SUB_SUP">TEXTOIDL_SUB_SUP</A>
<LI><A HREF="#TEXTOIDL_TABLE">TEXTOIDL_TABLE</A>
<LI><A HREF="#TEXTOIDL_TRANS_SUB_SUPER">TEXTOIDL_TRANS_SUB_SUPER</A>
<LI><A HREF="#YANNY_FREE">YANNY_FREE</A>
<LI><A HREF="#YANNY_PAR">YANNY_PAR</A>
<LI><A HREF="#YANNY_READ">YANNY_READ</A>
<LI><A HREF="#YANNY_WRITE">YANNY_WRITE</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="ANGDIDIS">
<H2>ANGDIDIS</H2></A>
<A HREF="#ATV">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   angdidis
 PURPOSE:
   Compute angular diameter distances (c/H_0=1).
 CALLING SEQUENCE:
   D= angdidis(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   angular diameter distance in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   The integrator is crude and slow, although it is not used when it is not
     necessary.
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
   propmotdis()
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//angdidis.pro)</STRONG><P>
<HR>
 
<A NAME="ATV">
<H2>ATV</H2></A>
<A HREF="#ANGDIDIS">[Previous Routine]</A>
<A HREF="#BSPLINE_BKPTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 Doug
 NAME:
       ATV
 
 PURPOSE: 
       Interactive display of 2-D images.

 CATEGORY: 
       Image display.

 CALLING SEQUENCE:
       atv [,array_name OR fits_file] [,min = min_value] [,max=max_value] 
           [,/autoscale] [,/linear] [,/log] [,/histeq] 

 REQUIRED INPUTS:
       None.  If atv is run with no inputs, the window widgets
       are realized and images can subsequently be passed to atv
       from the command line or from the pull-down file menu.

 OPTIONAL INPUTS:
       array_name: a 2-D data array to display
          OR
       fits_file:  a fits file name, enclosed in single quotes

 KEYWORDS:
       min:        minimum data value to be mapped to the color table
       max:        maximum data value to be mapped to the color table
       autoscale:  set min and max to show a range of data values
                      around the median value
       linear:     use linear stretch
       log:        use log stretch 
       histeq:     use histogram equalization
       
 OUTPUTS:
       None.  
 
 COMMON BLOCKS:
       atv_state:  contains variables describing the display state
       atv_images: contains the internal copies of the display image
       atv_color:  contains colormap vectors
       atv_pdata:  contains plot and text annotation information

 RESTRICTIONS:
       Requires IDL version 5.1 or greater.
       Requires Craig Markwardt's cmps_form.pro routine.
       Requires the GSFC IDL astronomy library routines,
         for fits input and world coordinate system information.
       Some features may not work under all operating systems.
       For a current list of atv's bugs and weirdnesses, go to
              http://cfa-www.harvard.edu/~abarth/atv/atv.html

 SIDE EFFECTS:
       Modifies the color table.

 EXAMPLE:
       To start atv running, just enter the command 'atv' at the idl
       prompt, either with or without an array name or fits file name 
       as an input.  Only one atv window will be created at a time,
       so if one already exists and another image is passed to atv
       from the idl command line, the new image will be displayed in 
       the pre-existing atv window.

 MODIFICATION HISTORY:
       Written by Aaron J. Barth, first release 17 December 1998.

       This version is 1.0b9, last modified 14 April 2000.
       For the most current version, revision history, instructions,
       and further information, go to:
              http://cfa-www.harvard.edu/~abarth/atv/atv.html

</PRE><P>
<STRONG>(See pro/plot//atv.pro)</STRONG><P>
<HR>
 
<A NAME="BSPLINE_BKPTS">
<H2>BSPLINE_BKPTS</H2></A>
<A HREF="#ATV">[Previous Routine]</A>
<A HREF="#BSPLINE_FIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   bspline_bkpts

 PURPOSE:
   Choose bkpts for b-spline given different constraints

 CALLING SEQUENCE:
   
   fullbkpt = bspline_bkpts(x, nord=nord, bkpt=bkpt, $
           bkspace=bkspace, nbkpts=nbkpts, everyn=everyn, silent=silent)

 INPUTS:
   bkpt       - Breakpoint vector returned by efc

 RETURNS:
   fullbkpt   - The fullbkpt vector required by evaluations with bvalu

 OPTIONAL KEYWORDS:
   bkspace    - Spacing of breakpoints in units of x
   everyn     - Spacing of breakpoints in good pixels
   nbkpts     - Number of breakpoints to span x range
                 minimum is 2 (the endpoints)
   silent     - Do not produce non-critical messages

 OPTIONAL OUTPUTS:
   bkpt       - breakpoints without padding

 COMMENTS:
   If both bkspace and nbkpts are passed, bkspace is used.

 EXAMPLES:

 PROCEDURES CALLED:
   none

 REVISION HISTORY:
   10-Mar-2000  Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/bspline//bspline_bkpts.pro)</STRONG><P>
<HR>
 
<A NAME="BSPLINE_FIT">
<H2>BSPLINE_FIT</H2></A>
<A HREF="#BSPLINE_BKPTS">[Previous Routine]</A>
<A HREF="#BSPLINE_ITERFIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   bspline_fit

 PURPOSE:
   Calculate a B-spline in the least-squares sense 
     based on two variables: x which is sorted and spans a large range
				  where bkpts are required
  		and 	      y which can be described with a low order
				  polynomial	

 CALLING SEQUENCE:
   
   error_code = bspline_fit(x, y, invvar, sset, $
                fullbkpt=fullbkpt, nord=, x2=, npoly=, yfit=)

 INPUTS:
   x          - independent variable
   y          - dependent variable
   invvar     - inverse variance of y
   sset       - Structure to be returned with all fit parameters

 RETURNS:
   error_code - Non negative numbers indicate ill-conditioned bkpts

 OUTPUTS:

 OPTIONAL KEYWORDS:
   fullbkpt   - Pass fullbkpt to seed structure
   nord       - Order of b-splines (4 is cubic, default)
   x2         - Orthogonal dependent variable
   npoly      - Order of x2 polynomial fit
   yfit       - evaluation of spline at x (&amp; x2)

 OPTIONAL OUTPUTS:

 COMMENTS:
   please sort x for this routine?  This might not be necessary
   replacement for efcmn and efc2d which calls slatec library

 EXAMPLES:


 PROCEDURES CALLED:

   efc_idl in src/slatec/idlwrapper.c
         which wraps to efc.o in libslatecidl.so

 REVISION HISTORY:
   20-Aug-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/bspline//bspline_fit.pro)</STRONG><P>
<HR>
 
<A NAME="BSPLINE_ITERFIT">
<H2>BSPLINE_ITERFIT</H2></A>
<A HREF="#BSPLINE_FIT">[Previous Routine]</A>
<A HREF="#BSPLINE_VALU">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   bspline_iterfit

 PURPOSE:
   Calculate a B-spline in the least squares sense with rejection

 CALLING SEQUENCE:
   sset = bspline_iterfit( )

 INPUTS:
   xdata      - Data x values
   ydata      - Data y values

 OPTIONAL KEYWORDS:
   invvar     - Inverse variance of y; if not set, then set to be
                consistent with the standard deviation.  This only matters
                if rejection is being done.
   nord       - Order for spline fit; default to 3 (cubic).
   x2         - 2nd dependent variable for 2-D spline fitting.
   npoly      - Polynomial order to fit over 2nd variable (X2); default to 2.
   xmin       - Normalization minimum for X2; default to MIN(XDATA).
   xmax       - Normalization maximum for X2; default to MAX(XDATA).
   oldset     - If set, then use values of FULLBKPT, NORD, XMIN, XMAX, NPOLY
                from this structure.
   maxiter    - Maximum number of rejection iterations; default to 0.
   EXTRA      - Keywords for BSPLINE_BKPTS() and/or DJS_REJECT().

 OUTPUTS:
   sset       - Structure describing spline fit.

 OPTIONAL OUTPUTS:
   outmask    - Output mask, set =1 for good points, =0 for bad points.

 COMMENTS:
   Data points can be masked either by setting their weights to zero
   (INVVAR[]=0), or by using INMASK and setting bad elements to zero.
   INMASK is passed to DJS_REJECT().

   If OLDSET is used, then the output structure SSET will be a structure
   with the same name as OLDSET.  This will allow the two structures to
   be concatented, i.e.
     &gt; junk = [oldset, sset]

 EXAMPLES:

 PROCEDURES CALLED:
   bspline_bkpts()
   bspline_fit()
   djs_reject()

 REVISION HISTORY:
   05-Sep-2000  Written by D. Schlegel &amp; S. Burles
</PRE><P>
<STRONG>(See pro/bspline//bspline_iterfit.pro)</STRONG><P>
<HR>
 
<A NAME="BSPLINE_VALU">
<H2>BSPLINE_VALU</H2></A>
<A HREF="#BSPLINE_ITERFIT">[Previous Routine]</A>
<A HREF="#BVALU2D">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   bspline_valu

 PURPOSE:
   This routine has TWO purposes.  
      1) Evaluate a bspline set (see create_bsplineset) at specified
            x and x2 arrays
      2) Construct banded bspline matrix, with dimensions [ndata, bandwidth]

 CALLING SEQUENCE:
   
   yfit  = bspline_valu( x, sset, x2=x2, action=action, indx=indx)

 INPUTS:
   x          - independent variable
   sset       - Structure to be returned with all fit parameters

 RETURNS:
   yfit       - Evaluated b-spline fit

 OPTIONAL KEYWORDS:
   x2         - Orthogonal dependent variable for 2d fits

 OPTIONAL OUTPUTS:
   action     - This keyword is overwritten with b-spline action matrix
   indx       - The index of bkpt which is just left of x[i], needed to
                  complete banded algebra

 COMMENTS:

 EXAMPLES:

 PROCEDURES CALLED:

 REVISION HISTORY:
   11-Sep-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/bspline//bspline_valu.pro)</STRONG><P>
<HR>
 
<A NAME="BVALU2D">
<H2>BVALU2D</H2></A>
<A HREF="#BSPLINE_VALU">[Previous Routine]</A>
<A HREF="#CMPS_FORM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   bvalu2d

 PURPOSE:
   Evaluate a bspline fit over 2 dependent variables

 CALLING SEQUENCE:
   
    z = bvalu2d(x, y, bkpt, coeff, ideriv=ideriv)

 INPUTS:
   x          - vector of x positions to evaluate
   y          - vector of y positions to evaluate
   bkpt       - Breakpoint vector returned by efc
   coeff      - B-spline coefficients calculated by efc 
		   2d in this case [npoly, nbkpt-nord]

 OPTIONAL KEYWORDS:

   ideriv     - Derivative to evaluate at x (default 0)

 OUTPUTS:
   z          - Evaluations corresponding to x positions

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:


 PROCEDURES CALLED:
   slatec_bvalu


 REVISION HISTORY:
   13-Mar-2000  Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/slatec//bvalu2d.pro)</STRONG><P>
<HR>
 
<A NAME="CMPS_FORM">
<H2>CMPS_FORM</H2></A>
<A HREF="#BVALU2D">[Previous Routine]</A>
<A HREF="#COMDIS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   CMPS_FORM

 PURPOSE:
   This function puts up a form the user can configure a PostScript
   device driver. The function result (if the user selects either the
   ACCEPT or CREATE FILE buttons) can be sent directly to the DEVICE
   procedure by means of its _Extra keyword.  User's predefined
   configurations may be retrieved from a common block.

 AUTHOR:
   *********** CM 01 Feb 2000 VERSION *************
   Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770
   craigm@lheamail.gsfc.nasa.gov

   Based almost entirely on, but a totally revamped version of, CMPS_FORM by 
   FANNING SOFTWARE CONSULTING (David Fanning Ph.D.) http://www.dfanning.com

 MAJOR TOPICS:
   Device Drivers, Hardcopy Output, PostScript Output

 PROCEDURE:
   This is a pop-up form widget. It is a modal or blocking widget.
   Keywords appropriate for the PostScript DEVICE command are returned.

   Use your LEFT mouse button to move the &quot;Plot Window&quot; around the page.
   Use your RIGHT mouse button to draw your own &quot;Plot Window&quot; on the page.

 HELP:
   formInfo = CMPS_FORM(/Help)

 CALLING SEQUENCE:
    formInfo = CMPS_FORM(xoffset, yoffset, Cancel=cancelButton)

 OPTIONAL INPUTS:

    XOFFSET -- Optional xoffset of the top-level base of cmps_form. Default is
    to try to center the form on the display.

    YOFFSET -- Optional yoffset of the top-level base of cmps_form. Default is
    to try to center the form on the display.

 INPUT KEYWORD PARAMETERS:

    BITS_PER_PIXEL -- The initial configuration of the bits per pixel button.

    BLOCKING -- Set this keyword to make this a blocking widget under IDL 5.0.
    (All widget programs block under IDL 4.0.)

    COLOR -- The initial configuration of the color switch.

    DEFAULTS -- A stucture variable of the same type and structure as the
    RETURN VALUE of cmps_form. It will set initial conditions. This makes
    it possible to start cmps_form up again with the same values it had the
    last time it was called. For example:

       mysetup = cmps_form()
       newsetup = cmps_form(Defaults=mysetup)

    ENCAPSULATED -- The initial configuration of the encapsulated switch.

    FILENAME -- The initial filename to be used on the form.

    HELP -- Prints a helpful message in the output log.

    INCHES -- The initial configuration of the inches/cm switch.

    INITIALIZE -- If this keyword is set, the program immediately returns the
    &quot;localdefaults&quot; structure. This gives you the means to configue the
    PostScript device without interrupting the user.

    SELECT -- used only when INITIALIZE is set.  Set SELECT to a
              string which identifies the predefined configuration to
              be returned by cmps_form when INITIALIZE is set.  This is
              a convenient way to select a predefined config
              non-interactively.

    LANDSCAPE -- The initial configuration of the landscape/portrait switch.

    LOCALDEFAULTS -- A structure like the DEFAULTS structure. If specified,
    then it is added as a predefined configuration entry called &quot;Local&quot;.
    See below for a further discussion of predefined configurations.

    PREDEFINED -- An alternate way to specify predefined
                  configurations.  Pass an array of structures to
                  populate the &quot;predefined&quot; dropbox in the
                  dialog. This array, if specified, overrides the the
                  common block technique.

    XOFFSET -- The initial XOffSet of the PostScript window.

    YOFFSET -- The initial YOffSet of the PostScript window.

    XSIZE -- The initial XSize of the PostScript window.

    YSIZE -- The initial YSize of the PostScript window.

    ASPECT -- The aspect ratio of the window (Y/X).  This keyword can
              substitute for one of XSIZE or YSIZE.
 
    PRESERVE_ASPECT -- Set this keyword if you want to hold the
                       aspect ratio constant.

    PAPERSIZE -- If set, allows user to specify the size of the paper
                 media to be printed on, as a scalar string.  NOTE:
                 this specification cannot be passed to DEVICE, but
                 can be selected for completeness's sake.  Default is
                 'Letter'.

    MARGINSIZE -- Size of the margins on all sides.  Default is 0.25 inches.
                  When MARGINSIZE is non-zero, a graphic cannot directly
                  abut the edge of the page.  This is normally a good thing,
                  since there is often a  non-printable region which borders
                  the page.

   DEFAULTPAPER -- Default paper size to use, when it is unspecified
                   in a predefined, &quot;local&quot;, or &quot;default&quot;
                   configuration.  This value also overrides any
                   configuration from common blocks.  European users
                   will probably set this to 'A4'.

   PARENT -- if this widget is invoked by another widget program,
             then this keyword parameter must be set to the top level
             widget which is to serve as the group leader.  Failure
             to do so will result in unexpected behavior.  IDL 4
             programs do not need to pass this parameter.  Default:
             NONE.

 OUTPUT KEYWORD PARAMETERS

    CANCEL -- This is an OUTPUT keyword. It is used to check if the user
    selected the &quot;Cancel&quot; button on the form. Check this variable rather
    than the return value of the function, since the return value is designed
    to be sent directly to the DEVICE procedure. The varible is set to 1 if
    the user selected the &quot;Cancel&quot; button. Otherwise, it is set to 0.

    CREATE -- This output keyword can be used to determine if the user
    selected the 'Create File' button rather than the 'Accept' button.
    The value is 1 if selected, and 0 otherwise.

    PAPERSIZE -- If set to a named variable, any newly selected paper
    size is returned in that variable.

    XPAGESIZE -- Size of paper in &quot;X&quot; dimension, in units given by
                 the returned config structure.

    YPAGESIZE -- Size of paper in &quot;Y&quot; dimension, in units given by
                 the returned config structure.

    PAGEBOX -- specifies the page rectangle relative to the plot
               window, in normalized units.  A 4-vector of the form
               [XLL, YLL, XUR, YUR] is returned, giving the positions
               of the lower left (LL) and upper right (UR) corners of
               the page with respect to the plot window.  Thus, the
               following command:

                    PLOT, x, y, position=PAGEBOX

               will construct a graphic whose plot region exactly
               fills the page (with no margin around the edges).

               Naturally, the page is usually larger than the
               graphics window, so the normalized coordinates will
               usually fall outside the range [0,1].

               However, the bounding box constructed by the
               Postscript driver includes only the graphics window.
               Anything drawn outside of it may be clipped or
               discarded.

 RETURN VALUE:

     formInfo = { cmps_form_INFO, $
                  xsize:0.0, $        ; The x size of the plot
                  xoff:0.0, $         ; The x offset of the plot
                  ysize:0.0, $        ; The y size of the plot
                  yoff:0.0 $          ; The y offset of the plot
                  filename:'', $      ; The name of the output file
                  inches:0 $          ; Inches or centimeters?
                  color:0, $          ; Color on or off?
                  bits_per_pixel:0, $ ; How many bits per image pixel?
                  encapsulated:0,$    ; Encapsulated or regular PostScript?
                  isolatin1:0,$       ; Encoded with ISOLATIN1?
                  landscape:0 }       ; Landscape or portrait mode?

 USAGE:

  The calling procedure for this function in a widget program will
  look something like this:

     info.ps_config = cmps_form(/Initialize)

     formInfo = cmps_form(Cancel=canceled, Create=create, $
                          Defaults=info.ps_config)

     IF NOT canceled THEN BEGIN
        IF create THEN BEGIN
           thisDevice = !D.Name
           Set_Plot, &quot;PS&quot;
           Device, _Extra=formInfo

           Enter Your Graphics Commands Here!

           Device, /Close
           Set_Plot, thisDevice
           info.ps_config = formInfo
        ENDIF ELSE
           info.ps_config = formInfo
     ENDIF

 MAJOR FUNCTIONS and PROCEDURES:

   None. Designed to work originally in conjunction with XWindow, a
   resizable graphics window.  [ NOTE: this modified version of
   cmps_form, by Craig Markwardt, is incompatible with the original
   version of XWINDOW. ]

 MODIFICATION HISTORY:

   Based on cmps_form of : David Fanning, RSI, March 1995.
   Major rewrite by: Craig Markwardt, October 1997.
     - Drawing and updating of form and sample box are now modular
     - Option of storing more than one predefined postscript configuration
     - Selection of paper size by name
     - Access to predfined configurations through (optional) common
       block
   Several additions, CM, April 1998  VERSION CM2.0
     - better integration of paper sizes throughout program.
       Predefined configurations now also know about paper.
     - allow passing predefined configurations instead of using
       common block
     - addition of ISOLATIN selection, and streamlining of dialog
       appearance
   Fixed bug in INITIALIZE w.r.t. paper sizes, CM, Nov 1998
   Added SELECT keyword, CM, 09 Dec 1998
   Added Parent keyword to allow modal widgets in IDL 5, 19 Jan 1999
   Added &quot;Choose&quot; button for filename selection, 19 Sep 1999
   Added ability to program different button names, 19 Sep 1999
   Added ASPECT and PRESERVE_ASPECT, based on work by Aaron Barth, 18
     Oct 1999
   Removed NOCOMMON documentation and logic, 19 Oct 1999, CM
   Added aspect to cmps_form_numevents (per Aaron Barth), 18 Oct 1999
   Corrected small bug under Initialize keyword (inches), 18 Oct 1999
   Made call to *_pscoord more consistent, 18 Oct 1999
   Added XPAGESIZE, YPAGESIZE and PAGEBOX keywords, 19 Oct 1999
   Small cosmetic cleanup, CM, 01 Feb 2000

 COMMON BLOCKS:
 
   The user may store frequently used or helpful configurations in a 
   common block, and cmps_form() will attempt to access them.  This
   provides a way for the user to have persistent, named,
   configurations.

   NOTE: this format has changed since the last version.  You may
   have to quit your IDL session for the changes to take effect
   properly.  If you have place a predefined configuration in your
   startup file, you should review the new format.
   
     COMMON CMPS_FORM_CONFIGS, cmps_form_DEFAULT_PAPERSIZE, $
                               cmps_form_STDCONFIGS

        cmps_form_DEFAULT_PAPERSIZE - a string designating the default
                                    paper size, when none is given.
                                    The predefined configurations
                                    offerred by this program will
                                    respect the default value.  (See
                                    also the DEFAULTPAPER keyword.)

        cmps_form_STDCONFIGS - An array of cmps_form_CONFIG structures,
                             each containing information about one
                             predefined configuration, such as its
                             name and size of paper.  Each &quot;config&quot;
                             element is a cmps_form_INFO structure,
                             which contains the actual postscript
                             configuration.

   See the IDL source code cmps_form_LOAD_CONFIGS for an example of how
   to make a list of configurations.  One possibility would be to
   declare and populate the common block from within the user's
   start-up script, allowing the same configurations to appear in
   every session.

   cmps_form() takes its initial list of configurations from this
   common block if it exists.  A default list is provided ala the
   procedure cmps_form_LOAD_CONFIGS.  Any modifications that take place
   during the cmps_form() widget session are not transferred back to
   the common block upon return.  It might be useful to be able to do
   this, through some form of 'save' procedure.

   Also, if the PREDEFINED keyword is used, then the common block is
   not consulted.

</PRE><P>
<STRONG>(See pro/plot//cmps_form.pro)</STRONG><P>
<HR>
 
<A NAME="COMDIS">
<H2>COMDIS</H2></A>
<A HREF="#CMPS_FORM">[Previous Routine]</A>
<A HREF="#CPBACKUP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   comdis
 PURPOSE:
   Compute comoving line-of-sight distances (c/H_0=1).
 CALLING SEQUENCE:
   D= comdis(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   comoving line-of-sight distance in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   The integrator is crude and slow.
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
   dcomdisdz()
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//comdis.pro)</STRONG><P>
<HR>
 
<A NAME="CPBACKUP">
<H2>CPBACKUP</H2></A>
<A HREF="#COMDIS">[Previous Routine]</A>
<A HREF="#DCOMDISDZ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   cpbackup

 PURPOSE:
   Copy a file to a backup file name.

 CALLING SEQUENCE:
   cpbackup, filename

 INPUTS:
   filename   - File to copy if it exists.

 OUTPUTS:

 COMMENTS:
   Make a backup copy of the specified file by appending &quot;.1&quot;, &quot;.2&quot;, etc.
   The first unused number is used as an appendix.

 EXAMPLES:

 BUGS:
   This is only written to work with a Unix file system, since it spawns
   the Unix &quot;cp&quot; command.

 PROCEDURES CALLED:

 REVISION HISTORY:
   11-Mar-2000  Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/misc//cpbackup.pro)</STRONG><P>
<HR>
 
<A NAME="DCOMDISDZ">
<H2>DCOMDISDZ</H2></A>
<A HREF="#CPBACKUP">[Previous Routine]</A>
<A HREF="#DISPLAY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   dcomdisdz
 PURPOSE:
   Compute differential comoving line-of-sight distances (c/H_0=1).
 CALLING SEQUENCE:
   dDdz= dcomdisdz(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   differential comoving distance DD/dz in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//dcomdisdz.pro)</STRONG><P>
<HR>
 
<A NAME="DISPLAY">
<H2>DISPLAY</H2></A>
<A HREF="#DCOMDISDZ">[Previous Routine]</A>
<A HREF="#DJS_ANGLE_GROUP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	DISPLAY

 PURPOSE:
	This procedure will display an image with the TV command that fills
	the plotting window.  It handles scale, annotations, X and PostScript
	devices, aspect ratios, logarithmic scaling, and interpolation.  
	Masked values and values below &lt;MIN&gt; are mapped to !P.BACKGROUND.
	Values above &lt;MAX&gt; are mapped to !P.COLOR.

 CATEGORY:
	Image display.

 CALLING SEQUENCE:
	DISPLAY, Image, XS, YS

 INPUTS:
	Image:	Two-dimensional array to be displayed.

 OPTIONAL INPUTS:
	XS:	Vector of x-axis values.  The length must equal the number of
		rows in &lt;Image&gt;

	YS:	Vector of y-axis values.  The length must equal the number of
		columns in &lt;Image&gt;

 KEYWORD PARAMETERS:
	TITLE=	Set this keyword to a string containing the title annotation
		to be used by PLOT.

	XTITLE=	Set this keyword to a string containing the x-axis annotation
		to be used by PLOT.

	YTITLE=	Set this keyword to a string containing the y-axis annotation
		to be used by PLOT.

	SUBTITLE=
		Set this keyword to a string containing the subtitle annotation
		to be used by PLOT.

	ASPECT=	Set this keyword to the aspect ratio (width/height) of the
		pixels.  /ASPECT is the same as ASPECT=1 and produces square
		pixels.

	/INTERPOLATE:
		Set this switch to enable bilinear interpolation for pixels
		in the expanded image.  See /PS_FINE for information
		on using this switch on a PostScript device.

	MASKVALUE=
		Set this keyword to the value that pixels with bad data or
		no data have been flagged with.  These will be mapped to 0B.

	MIN=	The minimum value of &lt;Image&gt; to be considered.  If MIN is not
		provided, &lt;Image&gt; is searched for its minimum value.  All
		values less than MIN are set to !P.BACKGROUND in the Result.

	MAX=	The maximum value of &lt;Image&gt; to be considered.  If MAX is not
		provided, &lt;Image&gt; is searched for its maximum value.  All
		values greater than MAX are set to !P.COLOR in the Result.

	BOT=	The minimum value of the scaled result.  If TOP is not
		specified, 0B is used.

	TOP=	The maximum value of the scaled result.  If TOP is not
		specified, 255B is used.

	LEVELS=	Set this keyword to a vector of data value boundaries between
		which all elements of &lt;Image&gt; have the same scaled byte
		value.  e.g. LEVELS=[0,1,2,5] maps all values below 0 and
		above 5 to 0B, map values between 0 and 1 to 1B, map values
		between 1 and 2 to 128B, and map values between 2 and 5 to
		255B.  This does not plot contours.

	/LOG:	Set this switch to cause a logarithmic mapping.  This is
		overridden by the LEVELS keyword.

	PS_FINE=
		Set to the approximate number of elements along an axis to 
		use in interpolating on a PostScript device.  Interpolation
		to the full indexable range of a PostScript device would be
		unwise.  This is only useful with /INTERPOLATE and
		will increase the size of the PostScript file.  The default
		size is 256 if PS_FINE= is not set or &lt;=0, 512 if 1 &lt; PS_FINE=
		&lt; 512, and take from the keyword if PS_FINE &gt; 512.

	/NOERASE:
		Set the switch to prevent output device from being erased
		before the image, scales, and annotations are displayed.

	/NO_EXPAND:
		Set this switch to prevent the image from being expanded
		to fill the plotting window.  Scaling to byte type is still
		performed.

 SIDE EFFECTS:
	TV display is altered.

 SUBORDINATE ROUTINES:
	IMGSCL()
	IMGEXP()
	COMP_DIST
	    SIMP_HIST()

 RESTRICTIONS:
	This routine may work for other devices, but it has only been tested
	on 'X' and 'PS'.

 PROCEDURE:
	Straight forward.  :-)

 EXAMPLE:
	LoadCT, 3
	image = SHIFT(DIST(20, 20), 10, 10)
	scale = FINDGEN(20) - 10.0
	DISPLAY, image, scale, scale, /INTERPOLATE, TITLE='!6Smooth Slope', $
		/ASPECT
	;Use CONTOUR with /OVERPLOT to overlay contours.
	CONTOUR, image, scale, scale, LEVELS=1.0+FINDGEN(4)*2.0, /OVERPLOT

	DISPLAY		;prints out a &quot;Usage:&quot; line

 MODIFICATION HISTORY:
 	Written by:	Fen Tamanaha, July 10, 1993.  Release 3.1
	July 13, 1993	Fen: (3.2) Fixed /No_Expand
	July 16, 1993	Fen: (3.3) Really fixed /No_Expand
</PRE><P>
<STRONG>(See pro/plot//display.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ANGLE_GROUP">
<H2>DJS_ANGLE_GROUP</H2></A>
<A HREF="#DISPLAY">[Previous Routine]</A>
<A HREF="#DJS_ANGLE_MATCH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_angle_group
 PURPOSE:
   Group objects using their coordinates on the sphere.

   Any coordinates within dtheta of one another are put in the same group.
   Note that if there is a string of successive objects on the sky, each
   separated by less than dtheta, then all of these objects are assigned
   to the same group.  This is incorrect in the sense that the first and
   last objects in the string may have a large separation; however, this
   is the only unambigious answer to the problem.

 CALLING SEQUENCE:
   ngroup = djs_angle_group( ra, dec, dtheta, $
    [gstart=gstart, gcount=gcount, gindx=gindx, units=units] )

 INPUTS:
   ra:         RA of point(s) in radians/degrees/hours
   dec:        DEC of point(s) in radians/degrees
   dtheta:     Maximum angular distance for points to be considered matches

 OPTIONAL INPUTS:
   units:      Set to
                  degrees - All angles in degrees
                  hrdeg - RA angles in hours, DEC angles and output in degrees
                  radians - All angles in radians
               Default to &quot;degrees&quot;.

 OUTPUTS:
   ngroup:     Total number of groups.  If no matches are found, then this
               equals the number of objects.

 OPTIONAL OUTPUTS:
   gstart:     Vector of length &quot;ngroup&quot; with the starting index of each group.
   gcount:     Vector of length &quot;ngroup&quot; with the number of objects in each
               group.
   gindx:      Indices of objects in each group.  The i-th group will have
               its object indices stored in gindx(gstart:gstart+gcount-1).

 PROCEDURES CALLED:

 INTERNAL SUPPORT PROCEDURES:
   djs_search_around

 REVISION HISTORY:
   29-May-1997  Written by D. Schlegel, Durham
   24-Feb-1999  Converted to IDL 5 (DJS).
</PRE><P>
<STRONG>(See pro/coord//djs_angle_group.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ANGLE_MATCH">
<H2>DJS_ANGLE_MATCH</H2></A>
<A HREF="#DJS_ANGLE_GROUP">[Previous Routine]</A>
<A HREF="#DJS_ANGLE_NMATCH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_angle_match

 PURPOSE:
   Given two lists of coordinates on a sphere, find matches within an
   angular distance.  For each entry in list A, find all the entries
   in list B that lie within an angular distance dtheta.
   Optionally output up to mmax of these matches per entry, giving
   the index number of the matches in mindx, and the angular distance
   in mdist.

   If the lists A and B are different, then the total number of pairs
   is given by total(mcount).
   If the lists A and B are the same, then the total number of unique
   pairs is given by (total(mcount) - N_elements(raA)) / 2.

   This function loops over the objects in each list (sort of), so it's
   not very fast.

 CALLING SEQUENCE:
   ntot = djs_angle_match( raA, decA, [raB, decB,] dtheta=dtheta, $
    [ mcount=mcount, mindx=mindx, mdist=mdist, mmax=mmax, units=units ]

 INPUTS:
   raA:        RA of first point(s) in radians/degrees/hours
   decA:       DEC of first point(s) in radians/degrees
   dtheta:     Maximum angular distance for points to be considered matches

 OPTIONAL INPUTS:
   raB:        RA of second point(s) in radians/degrees/hours
   decB:       DEC of second point(s) in radians/degrees
   mmax:       Maximum number of matches per point.  Default to 1.
   units:      Set to
                  degrees - All angles in degrees
                  hrdeg - RA angles in hours, DEC angles and output in degrees
                  radians - All angles in radians
               Default to &quot;degrees&quot;.

 OUTPUTS:
   ntot:       Total number of points A with one or more matches in B

 OPTIONAL OUTPUTS:
   mcount:     For each A, number of matches in B.  Vector of length A.
   mindx:      For each A, indices of matches in B, sorted by their distance.
               If mmax &gt; 1, this array is of dimensions (mmax, A).
               For each A, only the values (0:mcount-1,A) are relevant.
               If mmax = 1, then the return value is a vector.
               Any unused array elements are set to -1.
   mdist:      For each A, distance to matches in B, sorted by their distance.
               If mmax &gt; 1, this array is of dimensions (mmax, A).
               For each A, only the values (0:mcount-1,A) are relevant.
               If mmax = 1, then the return value is a vector.
               Any unused array elements are set to -1.

 COMMENTS:
   By specifying only one set of coordinates (raA, decA), matches are found
   within that list, but avoiding duplicate matches (i.e., matching 1 to 2
   and then 2 to 1) and avoiding matching an object with itself (i.e.,
   matching 1 to 1).  If you wish to include self-matches and duplicates,
   then call with raB=raA and decB=decA.

 PROCEDURES CALLED:
   djs_diff_angle()

 INTERNAL PROCEDURES:
   djs_angle_1match()
   djs_angle_2match()

 REVISION HISTORY:
   27-May-1997  Written by David Schlegel, Durham
   24-Feb-1999  Converted to IDL 5 (DJS)
   05-Mar-1999  Made the internal routines for more efficient matching
                within the same coordinate list without duplicates, e.g.
                by only specifying raA, decA and not raB, decB.
</PRE><P>
<STRONG>(See pro/coord//djs_angle_match.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ANGLE_NMATCH">
<H2>DJS_ANGLE_NMATCH</H2></A>
<A HREF="#DJS_ANGLE_MATCH">[Previous Routine]</A>
<A HREF="#DJS_ANGPOS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_angle_nmatch

 PURPOSE:
   Given two lists of coordinates on a sphere, find matches within an
   angular distance.  For each entry in list B, return the number of
   matches in list A that lie within an angular distance dtheta.

   This function loops through list A, so it is very slow if that list is long.

   The angle dtheta can be the same for each object in A, or may be set
   to a vector of length A.

   A list of indices where B has a match in A is where(nmatch GT 0).

 CALLING SEQUENCE:
   nmatch = djs_angle_nmatch( raA, decA, raB, decB, dtheta, $
    [ units=units ]

 INPUTS:
   raA:        RA of first point(s) in radians/degrees/hours
   decA:       DEC of first point(s) in radians/degrees
   raB:        RA of second point(s) in radians/degrees/hours
   decB:       DEC of second point(s) in radians/degrees
   dtheta:     Maximum angular distance for points to be considered matches

 OPTIONAL INPUTS:
   units:      Set to
                  degrees - All angles in degrees
                  hrdeg - RA angles in hours, DEC angles and output in degrees
                  radians - All angles in radians
               Default to &quot;degrees&quot;.

 OUTPUTS:
   nmatch:     For each B, number of matches with A

 PROCEDURES CALLED:
   djs_diff_angle()

 REVISION HISTORY:
   18-Jul-1997  Written by David Schlegel, Durham
                Modified from djs_angle_match().
   24-Feb-1999  Converted to IDL 5 (DJS)
</PRE><P>
<STRONG>(See pro/coord//djs_angle_nmatch.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ANGPOS">
<H2>DJS_ANGPOS</H2></A>
<A HREF="#DJS_ANGLE_NMATCH">[Previous Routine]</A>
<A HREF="#DJS_ANGSGN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_angpos
 PURPOSE:
   Put an angle into the range [0, 360).

 CALLING SEQUENCE:
   result = djs_angpos(xval)

 INPUTS:
   xval

 OUTPUTS:
   result

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written D. Schlegel, 17 June 1996, Durham
</PRE><P>
<STRONG>(See pro/coord//djs_angpos.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ANGSGN">
<H2>DJS_ANGSGN</H2></A>
<A HREF="#DJS_ANGPOS">[Previous Routine]</A>
<A HREF="#DJS_ARROW">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_angsgn
 PURPOSE:
  Put an angle into the range [-180, 180).

 CALLING SEQUENCE:
   result = djs_angsgn(xval)

 INPUTS:
   xval

 OUTPUTS:
   result

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written D. Schlegel, 17 June 1996, Durham
</PRE><P>
<STRONG>(See pro/coord//djs_angsgn.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ARROW">
<H2>DJS_ARROW</H2></A>
<A HREF="#DJS_ANGSGN">[Previous Routine]</A>
<A HREF="#DJS_AVSIGCLIP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_arrow

 PURPOSE:
   Modified version of ARROW to allow a string for the color(s)

 CALLING SEQUENCE:
   djs_arrow

 INPUT:

 OUTPUTS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 11 Dec 1998, Princeton
</PRE><P>
<STRONG>(See pro/plot//djs_arrow.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_AVSIGCLIP">
<H2>DJS_AVSIGCLIP</H2></A>
<A HREF="#DJS_ARROW">[Previous Routine]</A>
<A HREF="#DJS_AXIS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_avsigclip

 PURPOSE:
   Average multiple images with sigma-rejection.

 CALLING SEQUENCE:
   result = djs_avsigclip( array, [ dimension, sigrej=, maxiter=, $
    inmask=, outmask= ] )

 INPUTS:
   array      - N-dimensional array

 OPTIONAL INPUTS:
   dimension  - The dimension over which to collapse the data.  If ommitted,
                assume that the last dimension is the one to collapse.
   sigrej     - Sigma for rejection; default to 3.0.
   maxiter    - Maximum number of sigma rejection iterations.  One iteration
                does no sigma rejection; default to 10 iterations.
   inmask     - Input mask, setting =0 for good elements

 OUTPUTS:
   result     - The output array.
   outmask    - Output mask, setting =0 for good elements, =1 for bad.
                Any pixels masked in INMASK are also masked in OUTMASK.

 OPTIONAL OUTPUTS:

 COMMENTS:
   The DIMENSION input is analogous to that used by the IDL built-in
   function TOTAL.

 EXAMPLES:
   Create a data cube of 10 random-valued 100x200 images.  At each pixel in
   the image, compute the average of the 10 values, but rejecting 3-sigma
   outliers:
   &gt; array = randomu(123,100,200,10)
   &gt; ave = djs_avsigclip(array, sigrej=3)


   If all points are masked in any given vector or array, a mean and
   dispersion are computed for all the points.  Is this the behaviour we want?
   If you want to replace those values with zeros instead, look at OUTMASK:
   &gt; array = randomu(123,100,200)
   &gt; inmask = bytarr(100,200)
   &gt; inmask[*,8] = 1 ; mask all of row #8
   &gt; ave = djs_avsigclip(array, 1, inmask=inmask, outmask=outmask)
   &gt; ibad = where( total(1-outmask, 1) EQ 0)
   &gt; if (ibad[0] NE -1) then ave[ibad] = 0 ; zero-out bad rows

 BUGS:

 PROCEDURES CALLED:
   Dynamic link to arravsigclip.c

 REVISION HISTORY:
   07-Jul-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/math//djs_avsigclip.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_AXIS">
<H2>DJS_AXIS</H2></A>
<A HREF="#DJS_AVSIGCLIP">[Previous Routine]</A>
<A HREF="#DJS_CEIL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_axis

 PURPOSE:
   Modified version of AXIS

 CALLING SEQUENCE:
   djs_axis

 INPUT:

 OUTPUTS:

 PROCEDURES CALLED:
   TeXtoIDL()

 REVISION HISTORY:
   Written by D. Schlegel, 21 Jan 1998, Durham
</PRE><P>
<STRONG>(See pro/plot//djs_axis.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_CEIL">
<H2>DJS_CEIL</H2></A>
<A HREF="#DJS_AXIS">[Previous Routine]</A>
<A HREF="#DJS_CONTOURPTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_ceil

 PURPOSE:
   Return smallest integer not less than xvalue.
   This is identical to the C library function &quot;ceil()&quot;.

 CALLING SEQUENCE:
   result = djs_ceil(xvalue)

 INPUTS:
   xvalue

 OUTPUTS:
   result

 PROCEDURES CALLED:
   fix()

 REVISION HISTORY:
   Written D. Schlegel, 27 November 1996, Durham
</PRE><P>
<STRONG>(See pro/math//djs_ceil.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_CONTOURPTS">
<H2>DJS_CONTOURPTS</H2></A>
<A HREF="#DJS_CEIL">[Previous Routine]</A>
<A HREF="#DJS_CORRELATE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_contourpts

 PURPOSE:
   Make a contour plot from point data, drawing contours only where the
   point density is high.

 CALLING SEQUENCE:
   djs_contourpts

 INPUT:
   xpt:
   ypt:

 OPTIONAL KEYWORDS:
   bin1:
   bin2:
   overplot:  If set, then use current plot limits and overplot.
   nlevels:
   levels:
   loglevels: If set, then select NLEVEL (or 6) log-spaced levels
   nopoints:  If set, then do not plot any point data (only contours).
   psym:      Keyword for plotting point data; default to 3
   color:     Keyword for plotting point data

 OUTPUTS:

 OPTIONAL OUTPUTS:
   level0:    Lowest contour level
   ilow:      Indices for points outside the lowest contour level.

 PROCEDURES CALLED:
   djs_icolor()
   djs_oplot

 REVISION HISTORY:
   Written by D. Schlegel, 9 Dec 1998, Princeton
</PRE><P>
<STRONG>(See pro/plot//djs_contourpts.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_CORRELATE">
<H2>DJS_CORRELATE</H2></A>
<A HREF="#DJS_CONTOURPTS">[Previous Routine]</A>
<A HREF="#DJS_DIFF_ANGLE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_correlate

 PURPOSE:
   Compute a cross-correlation function using weights (or masks).

 CALLING SEQUENCE:
   result = djs_correlate( x, y, [ lags, xweight=, yweight= ] )

 INPUTS:
   x          - Vector
   y          - Vector, which may have a different number of elements from X

 OPTIONAL INPUTS:
   lags       - A scalar or integer vector specifying the lags at which
                to compute the cross-correlation; default to one lag at 0.
   xweight    - Vector of weights for X; default to 1 for all points
   yweight    - Vector of weights for Y; default to 1 for all points

 OUTPUTS:
   result     - The output vector, with one result per LAG value.

 OPTIONAL OUTPUTS:

 COMMENTS:
   This routine is similar to the IDL routine C_CORRELATE(), but with a
   few notable differences.  The X and Y vectors do not wrap when they are
   shifted, but rather only overlapping elements are compared at each lag.
   Because of this, X and Y do not have to have the same number of dimensions.
   A weight (or mask) can be assigned to each element of X,Y using the
   XWEIGHT,YWEIGHT keywords.  These weights can effectively be used to
   mask out regions of each vector by setting the weight to 1 for good
   pixels and 0 for bad ones.

   Each pixel of both X and Y are effectively weighted by XWEIGHT*YWEIGHT
   appropriately shifted before the multiplication.

 EXAMPLES:

 BUGS:
   The C routine only supports type FLOAT.

 PROCEDURES CALLED:
   Dynamic link to ccorrelate.c

 REVISION HISTORY:
   07-Jul-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/math//djs_correlate.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_DIFF_ANGLE">
<H2>DJS_DIFF_ANGLE</H2></A>
<A HREF="#DJS_CORRELATE">[Previous Routine]</A>
<A HREF="#DJS_FLOOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_diff_angle

 PURPOSE:
   Compute the angular distance between two points on a sphere.

   Note that either (ra1,dec1) or (rap,decp) must be scalars.

 CALLING SEQUENCE:
   adist = djs_diff_angle( ra, dec, ra0, dec0, [ units=units ] )

 INPUTS:
   ra1:        RA of first point(s) in radians/degrees/hours
   dec1:       DEC of first point(s) in radians/degrees
   rap:        RA of second point(s) in radians/degrees/hours
   decp:       DEC of second point(s) in radians/degrees

 OPTIONAL INPUTS:
   units:      Set to
                  degrees - All angles in degrees
                  hrdeg - RA angles in hours, DEC angles and output in degrees
                  radians - All angles in radians
               Default to &quot;degrees&quot;.

 OUTPUTS:
   adist:      Angular distance(s) in radians/degrees

 PROCEDURES CALLED:

 REVISION HISTORY:
   14-May-1997  Written by D. Schlegel, Durham
</PRE><P>
<STRONG>(See pro/coord//djs_diff_angle.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_FLOOR">
<H2>DJS_FLOOR</H2></A>
<A HREF="#DJS_DIFF_ANGLE">[Previous Routine]</A>
<A HREF="#DJS_HEX2BIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_floor

 PURPOSE:
   Return largest integer not greater than xvalue.
   This is identical to the C library function &quot;floor()&quot;.

 CALLING SEQUENCE:
   result = djs_floor(xvalue)

 INPUTS:
   xvalue

 OUTPUTS:
   result

 PROCEDURES CALLED:
   fix()

 REVISION HISTORY:
   Written D. Schlegel, 27 November 1996, Durham
</PRE><P>
<STRONG>(See pro/math//djs_floor.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_HEX2BIN">
<H2>DJS_HEX2BIN</H2></A>
<A HREF="#DJS_FLOOR">[Previous Routine]</A>
<A HREF="#DJS_HEX2INT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_hex2bin

 PURPOSE:
   Convert hexadecimal number(s) to binary numbers.

 CALLING SEQUENCE:
   binval = djs_hex2bin(hexval, [ndigit=ndigit])

 INPUTS:
   hexval:   String or array of strings containing hexadecimal number(s)

 OPTIONAL INPUTS:
   ndigit:   Number of binary digits in output; if not supplied, then the
             minimum number of digits are used

 OUTPUTS:
   intval:   Byte array(s) of binary values, dimensioned intval(ndigit,nnum)

 EXAMPLE:
   PRINT, DJS_HEX_TO_BINARY( '1a' )
   IDL prints the result
     0   1   0   1   1

   One can truncate to only the 4 least significan digits by setting NDIGIT:
   PRINT, DJS_HEX_TO_BINARY( '1a', NDIGIT=4 )
   IDL prints the result
     0   1   0   1

   PRINT, DJS_HEX_TO_BINARY( ['1a', '2b', '3'] )
   IDL prints the result
     0   1   0   1   1   0
     1   1   0   1   0   1
     1   1   0   0   0   0

 PROCEDURES CALLED:
   djs_hex2int()
   djs_int2bin()

 REVISION HISTORY:
   Written D. Schlegel, 30 June 1997, Durham
</PRE><P>
<STRONG>(See pro/math//djs_hex2bin.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_HEX2INT">
<H2>DJS_HEX2INT</H2></A>
<A HREF="#DJS_HEX2BIN">[Previous Routine]</A>
<A HREF="#DJS_ICOLOR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_hex2int

 PURPOSE:
   Convert hexadecimal number(s) to long integer(s).

 CALLING SEQUENCE:
   intval = djs_hex2int(hexval)

 INPUTS:
   hexval:   String or array of strings containing hexadecimal number(s)

 OUTPUTS:
   intval:   Long integer or array or long integers

 EXAMPLE:
   PRINT, DJS_HEX_TO_INT( '1a' )
   IDL prints the result
     26

   PRINT, DJS_HEX_TO_INT( ['1a', '2b', '3'] )
   IDL prints the result
     26  43   3

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written D. Schlegel, 30 June 1997, Durham
</PRE><P>
<STRONG>(See pro/math//djs_hex2int.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ICOLOR">
<H2>DJS_ICOLOR</H2></A>
<A HREF="#DJS_HEX2INT">[Previous Routine]</A>
<A HREF="#DJS_INT2BIN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_icolor

 PURPOSE:
   Internal routine for converting a color name to an index.

 CALLING SEQUENCE:
   icolor = djs_icolor(color)

 INPUT:
   color:

 OUTPUTS:
   icolor

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 27 September 1997, Durham
</PRE><P>
<STRONG>(See pro/plot//djs_icolor.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_INT2BIN">
<H2>DJS_INT2BIN</H2></A>
<A HREF="#DJS_ICOLOR">[Previous Routine]</A>
<A HREF="#DJS_ITERSTAT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_int2bin

 PURPOSE:
   Convert integer number(s) to binary numbers.

 CALLING SEQUENCE:
   binval = djs_int2bin(val, [ndigit=ndigit])

 INPUTS:
   val:      Integer number(s)

 OPTIONAL INPUTS:
   ndigit:   Number of binary digits in output; if not supplied, then the
             minimum number of digits are used

 OUTPUTS:
   binval:   Byte array(s) of binary values

 PROCEDURES CALLED:
   djs_floor()

 REVISION HISTORY:
   Written D. Schlegel, 30 June 1997, Durham
   31-Jul-1998  DJS - Subscripts modified to IDL 5 convention.
   03-Aug-1999  DJS - Modified to work with signed integers by
                first converting to unsigned integers.
</PRE><P>
<STRONG>(See pro/math//djs_int2bin.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_ITERSTAT">
<H2>DJS_ITERSTAT</H2></A>
<A HREF="#DJS_INT2BIN">[Previous Routine]</A>
<A HREF="#DJS_LAXISGEN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_iterstat

 PURPOSE:
   Compute the mean, median and/or sigma of data with iterative sigma clipping.

 CALLING SEQUENCE:
   djs_iterstat, image, [sigrej=, maxiter=, mean=, median=, sigma=, mask=]

 INPUTS:
   image:      Input data

 OPTIONAL INPUTS:
   sigrej:     Sigma for rejection; default to 3.0
   maxiter:    Maximum number of sigma rejection iterations; default to 10

 OUTPUTS:

 OPTIONAL OUTPUTS:
   mean:       Computed mean
   median:     Computed median
   sigma:      Computed sigma
   mask:       Mask set to 0 for good points, and 1 for rejected points

 PROCEDURES CALLED:

 COMMENTS:
   This routine is based upon Mark Dickinson's IRAF (!) script ITERSTAT.
   It iteratively rejects outliers as determined by SIGREJ.  It stops
   when one of the following conditions is met:
   (1) The maximum number of iterations, as set by MAXITER, is reached.
   (2) No new pixels are rejected, as compared to the previous iteration.
   (3) At least 2 pixels remain from which to compute statistics.  If not,
       then the returned values are based upon the previous iteration.

 BUGS:
   Raw IDL routines are WAY too slow; this would be much faster if it
     was cast into C - Hogg

 REVISION HISTORY:
   16-Jun-1999  Written by David Schlegel, Princeton
   11-Sep-2000  Speeded up by Hogg and Eisenstein
</PRE><P>
<STRONG>(See pro/math//djs_iterstat.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_LAXISGEN">
<H2>DJS_LAXISGEN</H2></A>
<A HREF="#DJS_ITERSTAT">[Previous Routine]</A>
<A HREF="#DJS_LOCATE_FILE()">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_laxisgen

 PURPOSE:
   Return a longword integer array with the specified dimensions.
   Each element of the array is set equal to its index number along
   the dimension IAXIS.

 CALLING SEQUENCE:
   result = djs_laxisgen( dimens, [ iaxis=iaxis ] )

 INPUT:
   dimens:     Vector of the dimensions for the result.
               Only up to 3 dimensions can be specified.
   iaxis:      Axis number to use for indexing RESULT.  The first dimension
               is axis number 0, the second 1, etc.  Default to 0.

 OUTPUTS:
   result:     Output array

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 7 Oct 1997, Durham
   Modified 12 May 1998 to pass one vector with all dimensions.
</PRE><P>
<STRONG>(See pro/misc//djs_laxisgen.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_LOCATE_FILE()">
<H2>DJS_LOCATE_FILE()</H2></A>
<A HREF="#DJS_LAXISGEN">[Previous Routine]</A>
<A HREF="#DJS_LOCKFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_locate_file()

 PURPOSE:
   Locate full file name (including path) of a file, searching IDL paths

 CALLING SEQUENCE:
   fullname = djs_locate_file( filename )

 INPUT:
   filename:   File name to find somewhere in path, including any extensions

 OUTPUTS:
   fullname:   File name of first located file (including full path),
               or '' if no matches found

 PROCEDURES CALLED:
   os_family()

 REVISION HISTORY:
   Written by D. Schlegel, 27 May 1997, Durham
   Modified version of GETPRO in Goddard library.
</PRE><P>
<STRONG>(See pro/misc//djs_locate_file.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_LOCKFILE">
<H2>DJS_LOCKFILE</H2></A>
<A HREF="#DJS_LOCATE_FILE()">[Previous Routine]</A>
<A HREF="#DJS_MASKINTERP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_lockfile

 PURPOSE:
   Test if a file is already &quot;locked&quot;, and lock it if not.

 CALLING SEQUENCE:
   res = djs_lockfile( filename, [lun= ] )

 INPUT:
   filename:   File name

 OPTIONAL INPUTS:
   lun:        If this argument exists, then open FILENAME for read/write
               access and return the pointer (LUN number) for that file.
               Do this only if we are able to lock the file.

 OUTPUTS:
   res:        Return 0 if file already locked, or 1 if not in which case
               we would have just locked it.

 COMMENTS:
   We use a lock file, which has a single byte written to it, to indicate
   that FILENAME should be locked (as determined by any subsequent calls
   to this routine).  Unlock files with DJS_UNLOCKFILE.

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   30-Apr-2000  Written by D. Schlegel, APO
</PRE><P>
<STRONG>(See pro/misc//djs_lockfile.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_MASKINTERP">
<H2>DJS_MASKINTERP</H2></A>
<A HREF="#DJS_LOCKFILE">[Previous Routine]</A>
<A HREF="#DJS_MEAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_maskinterp

 PURPOSE:
   Interpolate over masked pixels in a vector, image or 3-D array.

 CALLING SEQUENCE:
   ynew = djs_maskinterp( yval, mask, [ xval, iaxis=, /const ] )

 INPUTS:
   yval       - Y values; 1-, 2-, or 3-dimensional
   mask       - Mask values correspoding to YVAL; interpolate over all pixels
                where MASK is not 0

 OPTIONAL INPUTS:
   xval       - X (abscissa) values corresponding to YVAL; otherwise a
                regular grid is assumed
   iaxis      - Axis along which to interpolate if YVAL has more than one
                dimension; required keyword in that case; dimensions are
                0-indexed, so the X axis is IAXIS=0
   const      - The default is to linearly interpolate beyond the endpoints
                of good data.  Setting this keyword instead copied the
                first (last) good points for the data beyond the first (last)
                good points.

 OUTPUTS:
   ynew       - Y values after linearly interpolating over masked pixels

 COMMENTS:
   The IDL function INTERPOL is used for linear interpolation.

   If no good points exist in a vector, then that vector is returned
   unchanged.

 EXAMPLES:
   Create a sin-wave function, and interpolate across points at the beginning
   and in the middle of this function:
     xval=findgen(100)/10
     yval=sin(xval)
     splot,xval,yval
     mask=bytarr(100)
     mask[0:10]=1
     mask[40:60]=1
     ynew = djs_maskinterp(yval, mask, xval)
     plot,xval,yval
     oplot,xval,ynew,ps=2

 BUGS:
   This routine only supports 1-D, 2-D, and 3-D arrays.

 PROCEDURES CALLED:

 INTERNAL SUPPORT ROUTINS:
   djs_maskinterp1()

 REVISION HISTORY:
   27-Jan-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/image//djs_maskinterp.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_MEAN">
<H2>DJS_MEAN</H2></A>
<A HREF="#DJS_MASKINTERP">[Previous Routine]</A>
<A HREF="#DJS_MEDIAN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_mean

 PURPOSE:
   Return the mean value of an array.

 CALLING SEQUENCE:
   result = djs_mean(array)

 INPUTS:
   array      - Array of numbers

 OUTPUTS:
   result     - Computed mean

 PROCEDURES CALLED:

 COMMENTS:
   This function is faster than the IDL function MEAN(), and will not crash
   when passed a 1-element array.

 REVISION HISTORY:
   06-Oct-1997  Written by David Schlegel, Durham.
</PRE><P>
<STRONG>(See pro/math//djs_mean.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_MEDIAN">
<H2>DJS_MEDIAN</H2></A>
<A HREF="#DJS_MEAN">[Previous Routine]</A>
<A HREF="#DJS_MODFITS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_median

 PURPOSE:
   Return the median of an image either with a filtering box or by collapsing
   the image along one of its dimensions.

 CALLING SEQUENCE:
   result = djs_median( array, [ dimension, width=, boundary= ] )

 INPUTS:
   array      - N-dimensional array

 OPTIONAL INPUTS:
   dimension  - The dimension over which to compute the median, starting
                at one.  If this argument is not set, the median of all array
                elements (or all elements within the median window described
                by WIDTH) are medianed.
   width      - Width of median window; scalar value.
                It is invalid to specify both DIMENSION and WIDTH.
   boundary   - Boundary condition:
                'none': Do not median filter within WIDTH/2 pixels of
                        the edge; this is the default for both this
                        routine and MEDIAN().
                'nearest': Use the value of the nearest boundary pixel.
                        NOT IMPLEMENTED
                'reflect': Reflect pixel values around the boundary.
                'wrap': Wrap pixel values around the boundary.
                        NOT IMPLEMENTED
                These boundary conditions only take effect if WIDTH is set,
                and if ARRAY is either 1-dimensional or 2-dimensional.

 OUTPUTS:
   result     - The output array.  If neither DIMENSION nor WIDTH are set,
                then RESULT is a scalar.  If DIMENSION is not set and WIDTH
                is set, then RESULT has the same dimensions as ARRAY.
                If DIMENSION is set and WIDTH is not

 OPTIONAL OUTPUTS:

 COMMENTS:
   The DIMENSION input is analogous to that used by the IDL built-in
   function TOTAL.

   I should like to add the functionality of having WIDTH be an N-dimensional
   smoothing box.  For example, one should be able to median a 2-D image
   with a 3x5 filtering box.

 EXAMPLES:
   Create a 2-D image and compute the median of the entire image:
   &gt; array = findgen(100,200)
   &gt; print, djs_median(array)

   Create a data cube of 3 random-valued 100x200 images.  At each pixel in
   the image, compute the median of the 3:
   &gt; array = randomu(123,100,200,3)
   &gt; medarr = djs_median(array,3)

   Create a random-valued 2-D image and median-filter with a 9x9 filtering box:
   &gt; array = randomu(123,100,200)
   &gt; medarr = djs_median(array,9)

 BUGS:
   The C routine only supports type FLOAT.

 PROCEDURES CALLED:
   Dynamic link to arrmedian.c

 REVISION HISTORY:
   06-Jul-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/math//djs_median.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_MODFITS">
<H2>DJS_MODFITS</H2></A>
<A HREF="#DJS_MEDIAN">[Previous Routine]</A>
<A HREF="#DJS_OPLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_modfits

 PURPOSE:
   Wrapper for MODFITS that allows the header to increase in size.

 CALLING SEQUENCE:
   djs_modfits, filename, data, [hdr, exten_no=]

 INPUTS:
   filename  -
   data      -

 OPTIONAL INPUTS:
   hdr       -
   exten_no  -

 OUTPUTS:

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:

 BUGS:

 PROCEDURES CALLED:
   modfits
   mrdfits()
   mwrfits
   readfits()
   writefits

 INTERNAL PROCEDURES:
   bitsperpixel()

 REVISION HISTORY:
   17-May-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/fits//djs_modfits.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_OPLOT">
<H2>DJS_OPLOT</H2></A>
<A HREF="#DJS_MODFITS">[Previous Routine]</A>
<A HREF="#DJS_OPLOTERR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_oplot

 PURPOSE:
   Modified version of OPLOT.

 CALLING SEQUENCE:
   djs_oplot, [x,] y

 INPUT:
   x:
   y:

 OUTPUTS:

 COMMENTS:
   Allows COLOR, PSYM, and SYMSIZE to be vectors.
   Also allows COLOR to be string descriptions of eight possible colors.
   If string descriptors are used, then load a basic 8-color color table.

 PROCEDURES CALLED:
   djs_icolor()

 REVISION HISTORY:
   Written by D. Schlegel, 27 September 1997, Durham
</PRE><P>
<STRONG>(See pro/plot//djs_oplot.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_OPLOTERR">
<H2>DJS_OPLOTERR</H2></A>
<A HREF="#DJS_OPLOT">[Previous Routine]</A>
<A HREF="#DJS_PLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_oploterr

 PURPOSE:
   Modified version of OPLOTERR and DJS_OPLOT.

   Allows COLOR, PSYM, and SYMSIZE to be vectors.
   Also allows COLOR to be string descriptions of eight possible colors.
   If string descriptors are used, then load a basic 8-color color table.

 CALLING SEQUENCE:
   djs_oploterr, [x,] y, xerr=xerr, yerr=yerr, xlog=xlog, ylog=ylog, $
    cap=cap, xlen=xlen, ylen=ylen, $
    color=color, psym=psym, symsize=symsize

 INPUT:
   x:
   y:

 OPTIONAL INPUTS:
   xerr:   Error in X; or -1 for upper limit arrow, -2 for lower limit arrow
   yerr:   Error in Y; or -1 for upper limit arrow, -2 for lower limit arrow
   xlog:   If set, take the logarithm of X and its error
   ylog:   If set, take the logarithm of Y and its error
   cap:    If set, place caps on error bars
   xlen:   Length of upper/lower limit bars in X; default to 6% of plot range
   ylen:   Length of upper/lower limit bars in Y; default to 6% of plot range

 OUTPUTS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 5 February 1998, Durham
</PRE><P>
<STRONG>(See pro/plot//djs_oploterr.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_PLOT">
<H2>DJS_PLOT</H2></A>
<A HREF="#DJS_OPLOTERR">[Previous Routine]</A>
<A HREF="#DJS_PLOTLIMITBOX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_plot

 PURPOSE:
   Modified version of PLOT

 CALLING SEQUENCE:
   djs_plot, [x,] y

 INPUT:
   x:
   y:

 OUTPUTS:

 PROCEDURES CALLED:
  TeXtoIDL()

 REVISION HISTORY:
   Written by D. Schlegel, 27 September 1997, Durham
</PRE><P>
<STRONG>(See pro/plot//djs_plot.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_PLOTLIMITBOX">
<H2>DJS_PLOTLIMITBOX</H2></A>
<A HREF="#DJS_PLOT">[Previous Routine]</A>
<A HREF="#DJS_POSMOD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_plotlimitbox

 PURPOSE:
   Plot a box that bounds the given limits in X and Y.

 CALLING SEQUENCE:
   djs_plotlimitbox, xrange, yrange

 INPUT:
   xrange:    Range in X
   yrange:    Range in Y

 OUTPUTS:

 PROCEDURES CALLED:
   djs_oplot

 REVISION HISTORY:
   Written by D. Schlegel, 11 Dec 1998, Princeton
</PRE><P>
<STRONG>(See pro/plot//djs_plotlimitbox.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_POSMOD">
<H2>DJS_POSMOD</H2></A>
<A HREF="#DJS_PLOTLIMITBOX">[Previous Routine]</A>
<A HREF="#DJS_READCOL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_posmod

 PURPOSE:
   Return the non-negative modulus x % y, in the range [0,y).

 CALLING SEQUENCE:
   result = djs_posmod(x, y)

 INPUTS:
   xvalue

 OUTPUTS:
   result

 PROCEDURES CALLED:
   fix()

 REVISION HISTORY:
   Written D. Schlegel, 15 May 1997, Durham
</PRE><P>
<STRONG>(See pro/math//djs_posmod.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_READCOL">
<H2>DJS_READCOL</H2></A>
<A HREF="#DJS_POSMOD">[Previous Routine]</A>
<A HREF="#DJS_READILINES()">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	DJS_READCOL
 PURPOSE:
	Read a free-format ASCII data file with columns of data into IDL 
	variables.  Lines of data not meeting the specified format (e.g. 
	comments) are ignored.  Columns may be separated by commas or spaces.
	Use READFMT to read a fixed-format ASCII file.   Use RDFLOAT for
	much faster I/O (but less flexibility).

 CALLING SEQUENCE:
	DJS_READCOL, name, v1, [ v2, v3, v4, v5, ...  v25 , 
             FORMAT = , /DEBUG ,  /SILENT , SKIPLINE = , NUMLINE = ]

 INPUTS:
	NAME - Name of ASCII data file, scalar string.  In VMS, an extension of 
		.DAT is assumed, if not supplied.

 OPTIONAL INPUT KEYWORDS:
	FORMAT - scalar string containing a letter specifying an IDL type
		for each column of data to be read.  Allowed letters are 
		A - string data, B - byte, D - double precision, F- floating 
		point, I - integer, L - longword, and X - skip a column.

		Columns without a specified format are assumed to be floating 
		point.  Examples of valid values of FMT are

	'A,B,I'        ;First column to read as 6 character string, then 
			1 column of byte data, 1 column integer data
	'L,L,L,L'       ;Four columns will be read as longword arrays.
	' '             ;All columns are floating point

	If a FORMAT keyword string is not supplied, then all columns are 
	assumed to be floating point.

	SILENT - Normally, READCOL will display each line that it skips over.
		If SILENT is set and non-zero then these messages will be 
		suppressed.
	DEBUG - If this keyword is non-zero, then additional information is
		 printed as READCOL attempts to read and interpret the file.
	SKIPLINE - Scalar specifying number of lines to skip at the top of file
		before reading.   Default is to start at the first line.
	NUMLINE - Scalar specifying number of lines in the file to read.  
		Default is to read the entire file

 OUTPUTS:
	V1,V2,V3,...V15 - IDL vectors to contain columns of data.
		Up to 25 columns may be read.  The type of the output vectors
		are as specified by FORMAT.

 EXAMPLES:
	Each row in a file POSITION.DAT contains a star name and 6 columns
	of data giving an RA and Dec in sexigesimal format.   Read into IDL 
	variables.     (NOTE: The star names must not contain internal spaces.)

	IDL&gt; FMT = 'A,I,I,F,I,I,F'
	IDL&gt; READCOL,'POSITION',F=FMT,name,hr,min,sec,deg,dmin,dsec  

	The HR,MIN,DEG, and DMIN variables will be integer vectors.

	Alternatively, all except the first column could be specified as
	floating point.

	IDL&gt; READCOL,'POSITION',F='A',name,hr,min,sec,deg,dmin,dsec 

	To read just the variables HR,MIN,SEC
	IDL&gt; READCOL,'POSITION',F='X,I,I,F',HR,MIN,SEC

 RESTRICTIONS:
	This procedure is designed for generality and not for speed.
	If a large ASCII file is to be read repeatedly, it may be worth
	writing a specialized reader.

	Columns to be read as strings must not contain spaces or commas, 
	since these are interpreted as column delimiters.    Use READFMT
	to read such files.

	Numeric values are converted to specified format.  For example,
	the value 0.13 read with an 'I' format will be converted to 0.

 PROCEDURES CALLED
	GETTOK(), NUMLINES(), REPCHR(), STRNUMBER(), ZPARCHECK

 REVISION HISTORY:
	Written         W. Landsman                 November, 1988
	Modified	     J. Bloch 			June, 1991
	(Fixed problem with over allocation of logical units.)
	Added SKIPLINE and NUMLINE keywords  W. Landsman    March 92
	Read a maximum of 25 cols.  Joan Isensee, Hughes STX Corp., 15-SEP-93.
	Call NUMLINES() function W. Lansdman          Feb. 1996
</PRE><P>
<STRONG>(See pro/misc//djs_readcol.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_READILINES()">
<H2>DJS_READILINES()</H2></A>
<A HREF="#DJS_READCOL">[Previous Routine]</A>
<A HREF="#DJS_READLINES()">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_readilines()

 PURPOSE:
   Read selected lines of an ASCII file as one character string for each line.
   If NHEAD is specified and greater than zero, then that number
   of lines is read in first as header strings in HEAD.

 CALLING SEQUENCE:
   Data = djs_readilines( infile, indx=indx, [ nhead=nhead, Head=Head ] )

 INPUT:
   infile:      Input file name

 OPTIONAL INPUT:
   nhead:       Number of lines in header
   indx:        Line numbers to read (0-indexed); if not set, then
                default to reading all data lines in their current order.
                The indices start with 0 for the first data line.

 OUTPUTS:
   Data:        Array of strings, one for each data line

 OPTIONAL OUTPUTS:
   Head:        Array of strings, one for each header line

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 29 May 1997, Durham
</PRE><P>
<STRONG>(See pro/misc//djs_readilines.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_READLINES()">
<H2>DJS_READLINES()</H2></A>
<A HREF="#DJS_READILINES()">[Previous Routine]</A>
<A HREF="#DJS_READMANY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_readlines()

 PURPOSE:
   Read an ASCII file as one character string for each line.
   If NHEAD is specified and greater than zero, then that number
   of lines is read in first as header strings in HEAD.

 CALLING SEQUENCE:
   Data = djs_readlines( infile, [ nhead=nhead, Head=Head ] )

 INPUT:
   infile:      Input file name

 OPTIONAL INPUT:
   nhead:       Number of lines in header

 OUTPUTS:
   Data:        Array of strings, one for each data line

 OPTIONAL OUTPUTS:
   Head:        Array of strings, one for each header line

 PROCEDURES CALLED:

 REVISION HISTORY:
   Written by D. Schlegel, 29 May 1997, Durham
</PRE><P>
<STRONG>(See pro/misc//djs_readlines.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_READMANY">
<H2>DJS_READMANY</H2></A>
<A HREF="#DJS_READLINES()">[Previous Routine]</A>
<A HREF="#DJS_REJECT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_readmany

 PURPOSE:
   Read many FITS 2-D images into a data cube.

 CALLING SEQUENCE:
   cube = djs_readmany( files, [hdr=] )

 INPUTS:
   files:      FITS file names (array of strings)

 OUTPUTS:
   cube:       Data cube with dimensions [NAXIS1, NAXIS2, nfile]

 OPTIONAL OUTPUTS:
   hdr:        Header for first image

 COMMENTS:
   Additional keywords are passed to the function READFITS().
   At present, the output image is always typed FLOAT.

 PROCEDURES CALLED:
   readfits()

 REVISION HISTORY:
   07-Jul-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/fits//djs_readmany.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_REJECT">
<H2>DJS_REJECT</H2></A>
<A HREF="#DJS_READMANY">[Previous Routine]</A>
<A HREF="#DJS_SELECTLINES">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_reject

 PURPOSE:
   Routine to reject points when doing an iterative fit to data.

 CALLING SEQUENCE:
   qdone = djs_reject(ydata, ymodel, outmask=, [ inmask=, $
    sigma=, invvar=, upper=, lower=, maxdev=, $
    maxrej=, groupsize=, /sticky ] )

 INPUTS:
   ydata      - Data values
   ymodel     - Fit values

 REQUIRED KEYWORDS:
   outmask    - Output mask, usually from previous calls to DJS_REJECT(),
                set =1 for good points, =0 for bad points.
                If /STICKY is set, then bad pixels accumulate in this mask
                between calls.  Otherwise, this mask is only used to determine
                if the rejection iterations are complete (e.g., to set QDONE).
                This keyword is required to be present, though need not be set.

 OPTIONAL KEYWORDS:
   inmask     - Input mask, set =1 for good points, =0 for bad points;
                bad points always have OUTMASK=0 also.
   sigma      - Errors in YDATA, used to reject based upon UPPER and LOWER.
   invvar     - Inverse variance in YDATA, used to reject based upon UPPER
                and LOWER; cannot specify both SIGMA and INVVAR.
   upper      - Reject points with YDATA &gt; YMODEL + UPPER * SIGMA.
   lower      - Reject points with YDATA &lt; YMODEL - LOWER * SIGMA.
   maxdev     - Reject points with abs(YDATA - YMODEL) &gt; MAXDEV.
   maxrej     - Maximum number of points to reject this iteration.  If /STICKY
                is set, then this number of points can be rejected per
                iteration.
   groupsize  - If this and MAXREJ are set, then reject a maximum of MAXREJ
                points per group of GROUPSIZE points.
   sticky     - If set, then points rejected in OUTMASK are kept rejected.
                Otherwise, if a fit (YMODEL) changes between iterations,
                points can alternate from being rejected to not rejected.

 OUTPUTS:
   qdone      - Set to 0 if YMODEL is not set (usually the first call to
                this routine), or if the points marked as rejected in OUTMASK
                changes; set to 1 when the same points are rejected as from
                a previous call.

 OPTIONAL OUTPUTS:

 COMMENTS:
   If neither SIGMA nor INVVAR are set, then a scalar value of SIGMA is
   determined from the data points, excluding those points masked either
   with INMASK or OUTMASK.

   If the number of points rejected is limited with MAXREJ, then only the
   worst points are rejected.  The worst points are those with the largest
   deviation in terms of sigma (if UPPER or LOWER are set), or the largest
   number of multiples of MAXDEV from YMODEL (if MAXDEV is set).

   Note that UPPER, LOWER and MAXDEV can all be set.

 EXAMPLES:
   Construct an array of random numbers.  Reject high outliers, rejecting
   at most 1 point per iteration, for a maximum of 3 iterations:
     ydata = randomn(123,1000)
     ymodel = 0 * ydata
     sigma = 0 * ydata + 1
     outmask = 0
     maxiter = 3
     for iiter=0, maxiter do $
      if djs_reject(ydata, ymodel, outmask=outmask, upper=3, $
       maxrej=1, /sticky) then iiter = maxiter

   Usually, one would want to re-fit YMODEL between rejection iterations.
   The following does a weighted cubic fit to the data, but rejecting all
   points that deviate by more than 2-sigma from the fit.
     xdata = findgen(1000)
     ydata = randomn(123,1000)
     sigma = 0 * ydata + 1
     iiter = 0
     maxiter = 10
     outmask = 0 * ydata + 1 ; Begin with all points good
     while (NOT keyword_set(qdone) AND iiter LE maxiter) do begin
        qdone = djs_reject(ydata, ymodel, outmask=outmask, upper=2, lower=2)
        res = polyfitw(xdata, ydata, outmask/sigma^2, 2, ymodel)
        iiter = iiter + 1
     endwhile

 BUGS:
   Check case of no good points, or only 1 point with a value of 0
   (which might confuse keyword_set()). ???

 PROCEDURES CALLED:

 REVISION HISTORY:
   30-Aug-2000  Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/math//djs_reject.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_SELECTLINES">
<H2>DJS_SELECTLINES</H2></A>
<A HREF="#DJS_REJECT">[Previous Routine]</A>
<A HREF="#DJS_UNLOCKFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_selectlines

 PURPOSE:
   Select the line numbers specified by INDX of a file, and print either
   to the standard output or to another file.

   This is not yet optimized for very large files, as it will read in
   all of the requested lines (though not all the lines) into memory first.

 CALLING SEQUENCE:
   djs_selectlines, infile, [ indx=indx, nhead=nhead, outfile=outfile ]

 INPUTS:
   infile:      Input file name

 OPTIONAL INPUTS:
   indx:        Array of line numbers to select (0-indexed); default to all.
                The indices start with 0 for the first data line.
   nhead:       Number of lines in header
   outfile:     Output file name; if not set then print to terminal

 OUTPUTS:

 PROCEDURES CALLED:
   djs_readilines()

 REVISION HISTORY:
   Written by D. Schlegel, 25 September 1997, Durham
</PRE><P>
<STRONG>(See pro/misc//djs_selectlines.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_UNLOCKFILE">
<H2>DJS_UNLOCKFILE</H2></A>
<A HREF="#DJS_SELECTLINES">[Previous Routine]</A>
<A HREF="#DJS_XYOUTS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_unlockfile

 PURPOSE:
   Unlock a file if locked with DJS_LOCKFILE().

 CALLING SEQUENCE:
   djs_unlockfile, filename, [lun= ]

 INPUT:
   filename:   File name

 OPTIONAL INPUTS:
   lun:        If this argument exists, then close the file associated
               with this LUN number.  This is useful if FILENAME has
               been opened with DJS_LOCKFILE().

 OUTPUTS:

 COMMENTS:
   We use a lock file, which has a single byte written to it, to indicate
   that FILENAME has been locked by DJS_LOCKFILE().  This routine deletes
   that file.

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   30-Apr-2000  Written by D. Schlegel, APO
</PRE><P>
<STRONG>(See pro/misc//djs_unlockfile.pro)</STRONG><P>
<HR>
 
<A NAME="DJS_XYOUTS">
<H2>DJS_XYOUTS</H2></A>
<A HREF="#DJS_UNLOCKFILE">[Previous Routine]</A>
<A HREF="#DOTPRODUCT_SPHERE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   djs_xyouts

 PURPOSE:
   Modified version of XYOUTS

 CALLING SEQUENCE:
   djs_xyouts

 INPUT:

 OUTPUTS:

 COMMENTS:
   Allows COLOR, and CHARSIZE to be vectors.
   Also allows COLOR to be string descriptions of eight possible colors.
   If string descriptors are used, then load a basic 8-color color table.

 PROCEDURES CALLED:
   djs_icolor()
   TeXtoIDL()

 REVISION HISTORY:
   16-Apr-2000 Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/plot//djs_xyouts.pro)</STRONG><P>
<HR>
 
<A NAME="DOTPRODUCT_SPHERE">
<H2>DOTPRODUCT_SPHERE</H2></A>
<A HREF="#DJS_XYOUTS">[Previous Routine]</A>
<A HREF="#DPROPDISDZ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   dotproduct_sphere
 PURPOSE:
   Compute the cosign of the angle between two unit vectors on the
   sphere.  This formula is from Jackson, pg 101.  (Or see my notes
   of 6 Dec 92).  The angles must be in the following ranges:
     0 &lt;= phi &lt; 360
     0 &lt;= theta &lt;= 180
   where theta=0 corresponds to the N pole, and theta=180 is the S pole.
   If you want the dot product between RA and DEC coordinates,
   pass the following arguments (in radians):
     RA1, DEC1+90, RA2, DEC2+90

 CALLING SEQUENCE:
   dotproduct_sphere( phi1, theta1, phi2, theta2, [/degrees, /hrdeg] )

 INPUTS:
   phi1:       RA of first point(s) in radians
   theta1:     DEC of first point(s) in radians
   phi2:       RA of second point(s) in radians
   theta2:     DEC of second point(s) in radians

 OPTIONAL INPUTS:
   degrees:    If set, then all angles are in degrees
   hrdeg:      If se, then RA angles in hours and DEC angles in degrees

 OUTPUTS:
   cosgamma:   Cosine of the angle between the two positions
</PRE><P>
<STRONG>(See pro/coord//dotproduct_sphere.pro)</STRONG><P>
<HR>
 
<A NAME="DPROPDISDZ">
<H2>DPROPDISDZ</H2></A>
<A HREF="#DOTPRODUCT_SPHERE">[Previous Routine]</A>
<A HREF="#EFC2D">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   dpropdisdz
 PURPOSE:
   Compute differential proper line-of-sight distances (c/H_0=1).
 CALLING SEQUENCE:
   dDdz= dpropdisdz(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   differential proper distance DD/dz in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
   dcomdisdz()
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//dpropdisdz.pro)</STRONG><P>
<HR>
 
<A NAME="EFC2D">
<H2>EFC2D</H2></A>
<A HREF="#DPROPDISDZ">[Previous Routine]</A>
<A HREF="#EFCMN">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   efc2d

 PURPOSE:
   Calculate a B-spline in the least-squares sense 
     based on two variables: x which is sorted and spans a large range
				  where bkpts are required
  		and 	      y which can be described with a low order
				  polynomial	

 CALLING SEQUENCE:
   
   coeff = efc2d(x, y, z, invsig, npoly, nbkptord, fullbkpt)

 INPUTS:
   x          - data x values
   y          - data y values
   z          - data z values
   invsig     - inverse error array of y
   npoly      - Order of polynomial (as a function of y)
   nbkptord   - Order of b-splines (4 is cubic)
   fullbkpt   - Breakpoint vector returned by efc

 RETURNS:
   coeff      - B-spline coefficients calculated by efc

 OUTPUTS:

 OPTIONAL KEYWORDS:

 OPTIONAL OUTPUTS:

 COMMENTS:
	This IDL proc is an extension of efcmn

 EXAMPLES:

   x = findgen(100)
   y = randomu(200, 100, /normal)
   zmodel = 10.0*sin(x/10.0) + y
   z = zmodel + randomu(100,100,/normal)
   invsig = fltarr(100) + 1.0
   fullbkpt = [-3.0,-2.0,-1.0,findgen(11)*10.0,101.0,102.0,103.0]
   npoly = 2L
   nbkptord = 4L
   coeff = efc2d(x, y, z, invsig, npoly, nbkptord, fullbkpt)

   zfit = bvalu2d(x, y, fullbkpt, coeff)


 PROCEDURES CALLED:

   efc_idl in src/slatec/idlwrapper.c
         which wraps to efc.o in libslatecidl.so

 REVISION HISTORY:
   10-Mar-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/slatec//efc2d.pro)</STRONG><P>
<HR>
 
<A NAME="EFCMN">
<H2>EFCMN</H2></A>
<A HREF="#EFC2D">[Previous Routine]</A>
<A HREF="#FILEANDPATH">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   efcmn

 PURPOSE:
   Calculate a B-spline in the least-squares sense

 CALLING SEQUENCE:
   
   coeff = efcmn(x, y, invsig, nord, fullbkpt)

 INPUTS:
   x          - data x values
   y          - data y values
   invsig     - inverse error array of y
   nord       - Order of b-splines (default 4: cubic)
   fullbkpt       - Breakpoint vector returned by efc

 RETURNS:
   coeff      - B-spline coefficients calculated by efc

 OUTPUTS:

 OPTIONAL KEYWORDS:

 OPTIONAL OUTPUTS:

 COMMENTS:
	This IDL proc mimics efc.f

 EXAMPLES:

   x = findgen(100)
   y = randomu(100,100)
   invsig = fltarr(100) + 1.0
   fullbkpt = [-3.0,-2.0,-1.0,findgen(12)*10.0,101.0,102.0,103.0]
   nord = 4L

   coeff = efcmn(x, y, invsig, nord, fullbkpt)

   xfit = findgen(10)*10.0
   yfit = slatec_bvalu(xfit, fullbkpt, coeff)


 PROCEDURES CALLED:

   efc_idl in src/slatec/idlwrapper.c
         which wraps to efc.o in libslatecidl.so

 REVISION HISTORY:
   10-Mar-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/slatec//efcmn.pro)</STRONG><P>
<HR>
 
<A NAME="FILEANDPATH">
<H2>FILEANDPATH</H2></A>
<A HREF="#EFCMN">[Previous Routine]</A>
<A HREF="#FILL_BSPLINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   fileandpath

 PURPOSE:
   Split a file name into the path and the file name.

 CALLING SEQUENCE:
   filename = fileandpath(fullname, [path= ])

 INPUTS:
   fullname   - File name(s) which may include disk and/or directory
                specifications.

 OUTPUT:
   filename   - File name(s) without any disk or directory specifications.

 OPTIONAL OUTPUT:
   path       - Disk and directory specification(s).

 COMMENTS:
   This routine is meant to absorb any operating system dependencies.

 EXAMPLES:
   For Unix:
   IDL&gt; print, fileandpath('data/all/one.dat', path=path)
        one.dat
   IDL&gt; print, path
        data/all

 BUGS:

 PROCEDURES CALLED:
   fdecomp

 REVISION HISTORY:
   30-May-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/misc//fileandpath.pro)</STRONG><P>
<HR>
 
<A NAME="FILL_BSPLINE">
<H2>FILL_BSPLINE</H2></A>
<A HREF="#FILEANDPATH">[Previous Routine]</A>
<A HREF="#FINDBKPT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   fill_bspline

 PURPOSE:
   Calculate a B-spline in the least-squares sense 
     based on two variables: x which is sorted and spans a large range
				  where bkpts are required
  		and 	      y which can be described with a low order
				  polynomial	

 CALLING SEQUENCE:
   
   coeff = fill_bspline(x, y, z, invsig, npoly, nbkptord, fullbkpt)

 INPUTS:
   x          - data x values
   y          - data y values
   z          - data z values
   invsig     - inverse error array of y
   npoly      - Order of polynomial (as a function of y)
   nbkptord   - Order of b-splines (4 is cubic)
   fullbkpt   - Breakpoint vector returned by efc

 RETURNS:
   coeff      - B-spline coefficients calculated by efc

 OUTPUTS:

 OPTIONAL KEYWORDS:

 OPTIONAL OUTPUTS:

 COMMENTS:
   please sort x for this routine?  This might not be necessary
   replacement for efcmn and efc2d which calls slatec library

 EXAMPLES:


 PROCEDURES CALLED:

   efc_idl in src/slatec/idlwrapper.c
         which wraps to efc.o in libslatecidl.so

 REVISION HISTORY:
   20-Aug-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/bspline//fill_bspline.pro)</STRONG><P>
<HR>
 
<A NAME="FINDBKPT">
<H2>FINDBKPT</H2></A>
<A HREF="#FILL_BSPLINE">[Previous Routine]</A>
<A HREF="#FLOATCOMPRESS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   findbkpt

 PURPOSE:
   Choose bkpts for b-spline given different constraints

 CALLING SEQUENCE:
   
   fullbkpt = findbkpt(x, good, bkpt, nord, bkspace=bkspace, nbkpts=nbkpts, $
                   everyn=everyn, silent=silent)

 INPUTS:
   bkpt       - Breakpoint vector returned by efc

 RETURNS:
   fullbkpt   - The fullbkpt vector required by evaluations with bvalu

 OPTIONAL KEYWORDS:
   bkspace    - Spacing of breakpoints in units of x
   everyn     - Spacing of breakpoints in good pixels
   nbkpts     - Number of breakpoints to span x range
                 minimum is 2 (the endpoints)
   silent     - Do not produce non-critical messages

 OPTIONAL OUTPUTS:
   bkpt       - breakpoints without padding

 COMMENTS:
   If both bkspace and nbkpts are passed, bkspace is used.

 EXAMPLES:

 PROCEDURES CALLED:
   none

 REVISION HISTORY:
   10-Mar-2000  Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/slatec//findbkpt.pro)</STRONG><P>
<HR>
 
<A NAME="FLOATCOMPRESS">
<H2>FLOATCOMPRESS</H2></A>
<A HREF="#FINDBKPT">[Previous Routine]</A>
<A HREF="#GAUSSPIX1D">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   floatcompress

 PURPOSE:
   Make floating-point data more compressible by trimming binary digits. 
   The routine keeps the nfig most signifcant binary digits. 
   If keyword nsig is passed, the algorithm rounds to the nearest
   power of two less than nsig*sigma, where sigma is evaluated from
   the passed array (with 5 sigma outlier rejection). 

 CALLING SEQUENCE:
   out = floatcompress(data, ndig=ndig)

 INPUTS:
   data       - input data (type float or double)
                  WARNING: input data array is nuked to save memory
                  on large arrays. 

 OPTIONAL KEYWORDS:
   ndig       - number of binary significant digits to keep
   nsig       - number of sigma at which to round data

 OUTPUTS:
   out        - output data array with ndig significant binary digits
                kept and the rest zeroed. 

 COMMENTS:
   This function does not compress the data in an array, but fills
   unnecessary digits of the IEEE floating point representation with
   zeros.  This makes the data more compressible by standard
   compression routines such as compress or gzip. 
 
   The default is to retain 10 binary digits instead of the usual 23
   bits (or 52 bits for double precision), introducing a fractional
   error strictly less than 1/1024).  This is adequate for most
   astronomical images, and results in images that compress a factor
   of 2-4 with gzip. 

 EXAMPLES:
   image = readfits('map.fits')              ; read in FITS image
   outimage = floatcompress(image,ndig=8)    ; keep 8 binary digits
   writefits,'mapsmall.fits',outimage        ; write image
   
   Then from the UNIX shell
   &gt; gzip -8 mapsmall.fits

   (level 8 gzip is slower but more effective than average this is
       good for files that will be zipped once and unzipped many times)
 
 PERFORMANCE:
   On the typical maps of the ISM, gzip -8 compression factor is
   ~2.1.  Mileage may vary.  For some images, a factor of 4-5 is possible.

 BUGS:
   None known, but it is possible that there are floating point
   values that are corrupted due to round off errors.  Results should
   be double-checked.   

 PROCEDURES CALLED:

 REVISION HISTORY:
   05-Jul-2000 Written by Doug Finkbeiner (UC Berkeley)
   16-Sep-2000 Put in current format and commented -DPF
   22-Sep-2000 Added nsig keyword
</PRE><P>
<STRONG>(See pro/misc//floatcompress.pro)</STRONG><P>
<HR>
 
<A NAME="GAUSSPIX1D">
<H2>GAUSSPIX1D</H2></A>
<A HREF="#FLOATCOMPRESS">[Previous Routine]</A>
<A HREF="#IDLUTILS_VERSION">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   gausspix1d

 PURPOSE:
   Routine to evaluate a 1D gaussian function (plus polynomial terms)
   integrated over a pixel of width 1.

 CALLING SEQUENCE:
   gausspix, x, a, f, pder

 INPUTS:
   x          - Dependent variable [NX].
   a          - Coefficients:
                A[0] = center of the Gaussian in X
                A[1] = sigma width of the Gaussian
                A[2] = normalization of the Gaussian; total area = A[1] * A[2]
                A[3...] = polynomial coefficients for background terms

 OPTIONAL INPUTS:

 OUTPUTS:
   f          - Evaluated function [NX].
   pder       - Array of partial derivatives [NX,NCOEFF].

 OPTIONAL OUTPUTS:

 COMMENTS:
   This routine can be passed as a function to the IDL CURVEFIT function.

   If X is type DOUBLE, then the return values are also type DOUBLE;
   otherwise they are type FLOAT.

 EXAMPLES:

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   04-Aug-2000  Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/math//gausspix1d.pro)</STRONG><P>
<HR>
 
<A NAME="IDLUTILS_VERSION">
<H2>IDLUTILS_VERSION</H2></A>
<A HREF="#GAUSSPIX1D">[Previous Routine]</A>
<A HREF="#IMGEXP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   idlutils_version

 PURPOSE:
   Return the version name for the product idlutils

 CALLING SEQUENCE:
   vers = idlutils_version()

 INPUTS:

 OUTPUTS:
   vers       - Version name for the product idlutils

 COMMENTS:
   If this version is not tagged by CVS, then we return 'NOCVS: TOPLEVEL'
   where TOPLEVEL is the last directory in the environment variable
   $IDLUTILS_DIR.  For example, if you are using a version of the code
   in the directory '/u/schlegel/idlutils/v0_0', then this returns
   'NOCVS:v0_0'.

 BUGS:

 PROCEDURES CALLED:

; REVISION HISTORY:
   01-Dec-1999  Written by D. Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/misc//idlutils_version.pro)</STRONG><P>
<HR>
 
<A NAME="IMGEXP">
<H2>IMGEXP</H2></A>
<A HREF="#IDLUTILS_VERSION">[Previous Routine]</A>
<A HREF="#IMGSCL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	IMGEXP

 PURPOSE:
	This function expands the array &lt;Image&gt; to fill the current plotting
	window.  This routine works for both X and PostScript devices.  The
	optional scales &lt;XS&gt; and &lt;YS&gt; are likewise transformed and returned
	in option parameters &lt;Out_XS&gt; and &lt;Out_YS&gt;.

 CATEGORY:
	Image expansion.

 CALLING SEQUENCE:
	Result = IMGEXP(Image, XS, YS, Out_XS, Out_YS, X_Ran, Y_Ran)

 INPUTS:
	Image:	Two-dimensional array to be expanded.

 OPTIONAL INPUTS:
	XS:	Vector of x-axis values.  The length must equal the number of
		rows in &lt;Image&gt;

	YS:	Vector of y-axis values.  The length must equal the number of
		columns in &lt;Image&gt;

 KEYWORD PARAMETERS:
	ASPECT=	Set this keyword to the aspect ratio (width/height) of the
		pixels.  /ASPECT is the same as ASPECT=1 and produces square
		pixels.

	/INTERPOLATE:
		Set this switch to enable bilinear interpolation for pixels
		in the expanded image.  See /PS_INTERP_SIZE for information
		on using this switch on a PostScript device.

	MASKVALUE=
		Set this keyword to the value that uninterpolated pixels around
		the border of the image should be given.  The default is 
		-9999.0.  Interpolation is not performed beyond the centers of
		the original pixels.

	PS_INTERP_SIZE=
		Since PostScript devices have scalable pixels it is necessary
		to force expansion to at most this many pixels in either
		dimension.  The default is 256.  (It's really more complicated
		than this.  Read the code if you need to know.)

	POSITION=
		Set this keyword to the variable that is to hold the four-
		element vector containing the device coordinates of the
		plotting region that will contain the expanded image.  This
		is designed to be used by subsequent TV and PLOT commands.

	/NO_EXPAND:
		Set this switch to prevent the image from being expanded
		to fill the plotting window.  An aspect ration of 1:1 is
		forced for PostScript output so that it conforms to the X
		window view.

 OUTPUTS:
	Result:	This function returns an expanded version of the input &lt;Image&gt;
		possibly interpolated.

 OPTIONAL OUTPUTS:
	Out_XS:	Vector of x-axis values corresponding the the expanded image.

	Out_YS:	Vector of y-axis values corresponding the the expanded image.

	X_Ran:	Two-element vector that contains the full x-axis range
		including the width of the pixels.  It is designed to be used
		as input to the PLOT command.
	
	Y_Ran:	Two-element vector that contains the full y-axis range
		including the height of the pixels.  It is designed to be used
		as input to the PLOT command.
	
 RESTRICTIONS:
	This routine may work for other devices, but it has only been tested
	on 'X' and 'PS'.

 PROCEDURE:
	Straight forward.  :-)

 EXAMPLE:
	p = 0
	big = IMGEXP(small, lon, lat, biglon, biglat, xr, yr, Position=p)
	TVSCL, big, p(0), p(1), /Device
	Plot, [0,1], /NoData, /NoErase, Position=p, /Device, $
		XRange=xr, YRange=yr

	junk = IMGSCL( )	;prints out a &quot;Usage:&quot; line

 MODIFICATION HISTORY:
 	Written by:	Fen Tamanaha, July 9, 1993.  Release 2.1
	July 16, 1993	Fen: (2.2) Added /No_Expand keyword
       Jan 10, 2000    D. Finkbeiner - added _extra pass-through to Plot
</PRE><P>
<STRONG>(See pro/plot//imgexp.pro)</STRONG><P>
<HR>
 
<A NAME="IMGSCL">
<H2>IMGSCL</H2></A>
<A HREF="#IMGEXP">[Previous Routine]</A>
<A HREF="#INTRV">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	IMGSCL

 PURPOSE:
	This function mimics BYTSCL() except that it maps the input range
	into a byte range from 1 through TOP.  A byte value of 0 is reserved
	for elements containing MASKVALUE usually assigned for bad pixels or
	those without data.  The function can also perform logarithmic scaling
	of the data into byte values.  Use of the LEVELS keyword will scale
	all value within a given level to a single byte value.

 CATEGORY:
	Image scaling.

 CALLING SEQUENCE:
	Result = IMGSCL(Array)

 INPUTS:
	Array:	Two-dimensional array to be expanded.

 KEYWORD PARAMETERS:
	MIN=	The minimum value of Array to be considered.  If MIN is not
		provided, Array is searched for its minimum value.  All
		values less than or equal to MIN are set to 1 in the Result.

	MAX=	The maximum value of Array to be considered.  If MAX is not
		provided, Array is searched for its maximum value.  All
		values greater than or equal to MAX are set to TOP in the
		Result.

	TOP=	The maximum value of the scaled result.  If TOP is not
		specified, 255 is used. Note that the minimum value of the
		scaled result is always 1 (NOT 0 as in BYTSCL).

	LEVELS=	Set this keyword to a vector of data value boundaries between
		which all elements of the Array have the same scaled byte
		value.  e.g. LEVELS=[0,1,2,5] maps all values below 0 and
		above 5 to 0B, map values between 0 and 1 to 1B, map values
		between 1 and 2 to 128B, and map values between 2 and 5 to
		255B.

	/LOG:	Set this switch to cause a logarithmic mapping.  This is
		overridden by the LEVELS keyword.

	MASKVALUE=
		Set this keyword to the value that pixels with bad data or
		no data have been flagged with.  These will be mapped to 0B.

 OUTPUTS:
	Result:	This function returns a byte array between 1 and TOP for data
		in Array between MIN and MAX.

 RESTRICTIONS:

 PROCEDURE:
	Straight forward.  :-)

 EXAMPLE:
	image = IMGSCL(array, Min=-1, Top=!D.Table_Size-1, /Log, Mask=-9999.0)
	TV, image

	image = IMGSCL(array, Levels=[0,1,2,4,8,16,32])
	TV, image		;plot with 6 colors plus the background

 MODIFICATION HISTORY:
 	Written by:	Fen Tamanaha, July 10, 1993.  Release 2.1
</PRE><P>
<STRONG>(See pro/plot//imgscl.pro)</STRONG><P>
<HR>
 
<A NAME="INTRV">
<H2>INTRV</H2></A>
<A HREF="#IMGSCL">[Previous Routine]</A>
<A HREF="#LUMDIS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   intrv

 PURPOSE:
   Calculate a B-spline in the least-squares sense 
     based on two variables: x which is sorted and spans a large range
				  where bkpts are required
  		and 	      y which can be described with a low order
				  polynomial	

 CALLING SEQUENCE:
   
   coeff = efc2d(x, y, z, invsig, npoly, nbkptord, fullbkpt)

 INPUTS:
   x          - data x values
   y          - data y values
   z          - data z values
   invsig     - inverse error array of y
   npoly      - Order of polynomial (as a function of y)
   nbkptord   - Order of b-splines (4 is cubic)
   fullbkpt   - Breakpoint vector returned by efc

 RETURNS:
   coeff      - B-spline coefficients calculated by efc

 OUTPUTS:

 OPTIONAL KEYWORDS:

 OPTIONAL OUTPUTS:

 COMMENTS:
   does the same function as intrv, although slower but easier to follow
    sorting is done here, so we can skip it fill_bspline??

 EXAMPLES:

 REVISION HISTORY:
   31-Aug-2000 Written by Scott Burles, FNAL
</PRE><P>
<STRONG>(See pro/bspline//intrv.pro)</STRONG><P>
<HR>
 
<A NAME="LUMDIS">
<H2>LUMDIS</H2></A>
<A HREF="#INTRV">[Previous Routine]</A>
<A HREF="#MODFITSCARD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   lumdis
 PURPOSE:
   Compute luminosity distances (c/H_0=1).
 CALLING SEQUENCE:
   D= lumdis(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   luminosity distance in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   The integrator is crude and slow, although it is not used when it is not
     necessary.
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
   propmotdis()
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//lumdis.pro)</STRONG><P>
<HR>
 
<A NAME="MODFITSCARD">
<H2>MODFITSCARD</H2></A>
<A HREF="#LUMDIS">[Previous Routine]</A>
<A HREF="#POPULATE_IMAGE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   modfitscard

 PURPOSE:
   Modify FITS card(s) in a file without changing the data.

 CALLING SEQUENCE:
   modfitscard, filename, card, value, [ comment, /delete, $
    _EXTRA=KeywordsForSxaddpar ]

 INPUTS:
   filename  - File name(s) to modify; this can be an array of file names,
               and it can include wildcards
   card      - Name of FITS card(s) to add or modify

 OPTIONAL INPUTS:
   value     - New value(s) for FITS card; mandatory card if DELETE not set;
               must have the same number of elements as CARD.
   comment   - Comment to appear in the card after its value; passed to
               the routine SXADDPAR.  If specified, it must have the same
               number of elements as CARD.
   delete    - If set, then delete all cards CARD from the header;
               VALUE is ignored if set.

 OUTPUTS:

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:
   Modify the value of the DATE keyword in the primary header of all FITS
   files with '666' or '777' in the file name:
   IDL&gt; modfitscard, ['*666*.fits','*777*.fits'], 'DATE', '1994-03-23'

 BUGS:
   This routine calls DJS_MODFITS, which allows the size of the header
   to be changed.

   Wildcards are not supported for CARD, so you cannot say something like
   IDL&gt; modfitscard, 'test.fits', 'DATE*', '1994-03-23' ; Will not work!

 PROCEDURES CALLED:
   djs_modfits
   headfits()
   sxaddpar

 REVISION HISTORY:
   19-Apr-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/fits//modfitscard.pro)</STRONG><P>
<HR>
 
<A NAME="POPULATE_IMAGE">
<H2>POPULATE_IMAGE</H2></A>
<A HREF="#MODFITSCARD">[Previous Routine]</A>
<A HREF="#PROPMOTDIS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   populate_image

 PURPOSE:
   Populate a vector or image with weights at the specified positions.

 CALLING SEQUENCE:
   populate_image, image, x, [y, weights=, assign=]

 INPUTS:
   image      - Image vector or array
   x          - X coordinate(s) of locations to populate, 0-indexed

 OPTIONAL INPUTS:
   y          - Y coordinate(s) of locations to populate, 0-indexed
   weights    - Weight(s) to add at each X or X,Y position
   assign     - Assignment scheme:
                'ngp': nearest grid point assignment; default
                'cic': cloud-in-cell assignment

 OUTPUTS:
   image      - (Modified)

 COMMENTS:
   IMAGE, X, and Y are treated as floating-point values for the assignment.

 BUGS:

 PROCEDURES CALLED:
   Dynamic link to pop_image.c

 REVISION HISTORY:
   17-May-2000  Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/image//populate_image.pro)</STRONG><P>
<HR>
 
<A NAME="PROPMOTDIS">
<H2>PROPMOTDIS</H2></A>
<A HREF="#POPULATE_IMAGE">[Previous Routine]</A>
<A HREF="#QZAP.PRO">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   propmotdis
 PURPOSE:
   Compute proper motion distances (c/H_0=1).
 CALLING SEQUENCE:
   D= propmotdis(z,OmegaM,OmegaL)
 INPUTS:
   z       - redshift or vector of redshifts
   OmegaM  - Omega-matter at z=0
   OmegaL  - Omega-Lambda at z=0
 OPTIONAL INPUTS:
 KEYWORDS
 OUTPUTS:
   proper motion distance in units of the Hubble length c/H_0
 COMMENTS:
 BUGS:
   The integrator is crude and slow, although it is not used when it is not
     necessary.
   May not work for pathological parts of the OmegaM-OmegaL plane.
 EXAMPLES:
 PROCEDURES CALLED:
 REVISION HISTORY:
   25-Jun-2000  Written by Hogg (IAS)
</PRE><P>
<STRONG>(See pro/cosmography//propmotdis.pro)</STRONG><P>
<HR>
 
<A NAME="QZAP.PRO">
<H2>QZAP.PRO</H2></A>
<A HREF="#PROPMOTDIS">[Previous Routine]</A>
<A HREF="#RMFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   qzap.pro

 PURPOSE:
   Remove cosmic rays from a 2-D image.

 CALLING SEQUENCE:
   qzap, name, outname, [ outmaskname, skyfiltsize=skyfiltsize, $
    boxsize=boxsize, nsigma=nsigma, /nofluxratio, maxiter=maxiter, $
    fluxcompare=fluxcompare, nrings=nrings, path=path, nzap=nzap ]

 INPUTS:
   name       - 2-D image array, or name of input FITS file.
   outname    - Output image array, or name of output FITS file.

 OPTIONAL INPUTS:
   outmaskname- Output mask array, or name of output FITS file.
   skyfiltsize- Boxsize for computing local sky value; default to 15.
   boxsize    - Boxsize for computing local median; default to 5.
   nsigma     - Rejection threshhold in sigma; default to 4.
   fluxratio  - Comparison value for identifying cosmics; default to 0.15
   maxiter    - Number of zapping iterations; default to 2.
   nofluxcompare - Set to disable the flux comparison algorithm, which
                is the &quot;black magic&quot; heart of this routine.
   nrings     - Radius of cosmic ray neighbors to also zap; default to 1.
   path       - Input/output path name

 OPTIONAL OUTPUTS:
   NZAP       - Number of pixels zapped.

 COMMENTS:
   Based on the tried and true IRAF QZAP routine by Mark Dickinson.
   Results from IDL qzap.pro and IRAF QZAP are found to be virtually
   identical.

 PROCEDURES CALLED:
   djs_iterstat

 REVISION HISTORY:
   20-Aug-1999  Written by Cullen Blake &amp; David Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/image//qzap.pro)</STRONG><P>
<HR>
 
<A NAME="RMFILE">
<H2>RMFILE</H2></A>
<A HREF="#QZAP.PRO">[Previous Routine]</A>
<A HREF="#SLATEC_BVALU">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   rmfile

 PURPOSE:
   Delete file from disk.

 CALLING SEQUENCE:
   rmfile, filename

 INPUTS:
   filename   - File to delete.

 OUTPUTS:

 COMMENTS:

 EXAMPLES:

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   14-Oct-1999  Written by D. Schlegel, APO
</PRE><P>
<STRONG>(See pro/misc//rmfile.pro)</STRONG><P>
<HR>
 
<A NAME="SLATEC_BVALU">
<H2>SLATEC_BVALU</H2></A>
<A HREF="#RMFILE">[Previous Routine]</A>
<A HREF="#SLATEC_EFC">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   slatec_bvalu

 PURPOSE:
   Evaluate a bspline 

 CALLING SEQUENCE:
   
    y = slatec_bvalu(x, fullbkpt, coeff, ideriv=ideriv)

 INPUTS:
   x          - Vector of positions to evaluate
   fullbkpt   - Breakpoint vector returned by SLATEC_EFC()
   coeff      - B-spline coefficients calculated by SLATEC_EFC()

 OPTIONAL KEYWORDS:
   ideriv     - Derivative to evaluate at x; default to 0

 OUTPUTS:
   y          - Evaluations corresponding to x positions

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:

 PROCEDURES CALLED:
   Dynamic link to bvalu_idl in slatec/src/idlwrapper.c,
   which calls bvalu.f in the library &quot;libslatecidl.so&quot;.

 REVISION HISTORY:
   15-Oct-1999  Written by Scott Burles, Chicago
</PRE><P>
<STRONG>(See pro/slatec//slatec_bvalu.pro)</STRONG><P>
<HR>
 
<A NAME="SLATEC_EFC">
<H2>SLATEC_EFC</H2></A>
<A HREF="#SLATEC_BVALU">[Previous Routine]</A>
<A HREF="#SLATEC_SPLINEFIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   slatec_efc

 PURPOSE:
   Calculate a B-spline in the least-squares sense

 CALLING SEQUENCE:
   
   fullbkpt = slatec_efc(x, y, coeff, bkpt=bkpt, nord=nord, $
    invsig=invsig, bkspace=bkspace, nbkpts=nbkpts, everyn=everyn, /silent)

 INPUTS:
   x          - data x values
   y          - data y values

 OPTIONAL INPUTS:
   bkpt       - Breakpoint vector returned by efc (without padding)

 OPTIONAL KEYWORDS:
   nord       - Order of b-splines (default 4: cubic)
   invsig     - Inverse of sigma for weighted fit
   bkspace    - Spacing of breakpoints in units of x
   everyn     - Spacing of breakpoints in good pixels
   nbkpts     - Number of breakpoints to span x range
                 minimum is 2 (the endpoints)
   silent     - Do not produce non-critical messages
   x2         - 2nd dependent variable for 2d fitting
   npoly      - polynomial order to fit over 2nd variable, default 2


 OUTPUTS:
   coeff      - B-spline coefficients calculated by efc
   fullbkpt   - The fullbkpt vector required by evaluations with bvalu

 OPTIONAL OUTPUTS:
   bkpt       - Breakpoints without padding

 COMMENTS:
   If both bkspace and nbkpts are passed, bkspace is used.
   X values must be sorted.

 EXAMPLES:

   x = findgen(100)
   y = randomu(100,100)
   fullbkpt = slatec_efc(x, y, coeff, bkspace = 10.0)

   xfit = findgen(10)*10.0
   yfit = bvalu(xfit, fullbkpt, coeff)


 PROCEDURES CALLED:
   findbkpt()

   efc_idl in src/slatec/idlwrapper.c
         which wraps to efc.o in libslatecidl.so

 REVISION HISTORY:
   15-Oct-1999  Written by Scott Burles, Chicago
</PRE><P>
<STRONG>(See pro/slatec//slatec_efc.pro)</STRONG><P>
<HR>
 
<A NAME="SLATEC_SPLINEFIT">
<H2>SLATEC_SPLINEFIT</H2></A>
<A HREF="#SLATEC_EFC">[Previous Routine]</A>
<A HREF="#SPLOT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   slatec_splinefit

 PURPOSE:
   Calculate a B-spline in the least squares sense with rejection

 CALLING SEQUENCE:
   
   fullbkpt = slatec_splinefit(x, y, coeff, invvar=, x2=, npoly=, $
    bkpt=, fullbkpt=, maxiter=, upper=, lower=, $
    rejper=, /eachgroup, /secondkludge, $
    mask=, _EXTRA=KeywordsForEfc)

 INPUTS:
   x          - Data x values
   y          - Data y values
   bkpt       - Breakpoint vector returned by SLATEC_EFC()

 OPTIONAL KEYWORDS:
   invvar     - Inverse variance of y; if not set, then set to be
                consistent with the standard deviation.  This only matters
                if rejection is being done.
   x2         - 2nd dependent variable for 2-D fitting 
   npoly      - Polynomial order to fit over 2nd variable (X2); default to 2.
   maxiter    - maximum number of iterations (default 5)
   upper      - Sigma rejection threshold for positive deviations; default to 5
   lower      - Sigma rejection threshold for negative deviations; default to 5
   rejper     - Alternative rejection algorithm, rejecting at most the
                fraction REJPER of the points per iteration (but rejecting
                at least one point if there are any bad ones).
   eachgroup  - Alternative rejection algorithm ???
   secondkludge - ???

 KEYWORDS FOR SLATEC_EFC:
   nord
   bkspace
   nbkpts
   everyn

 OUTPUTS:
   fullbkpt   - The fullbkpt vector required by evaluations with
                SLATEC_BVALU().  Return -1 if the spline fit fails
                due to all points (or all but 1) being rejected.

 OPTIONAL OUTPUTS:
   coeff      - B-spline coefficients calculated by SLATEC_EFC().
   bkpt       - Breakpoints without padding
   mask       - Mask array, set to 0 for good points and 1 for rejected points

 COMMENTS:
   If both bkspace and nbkpts are passed, bkspace is used

 EXAMPLES:

   x = findgen(100)
   y = randomu(100,100)
   fullbkpt = slatec_splinefit(x, y, coeff, invvar=invvar, nbkpts=10)

   xfit = findgen(10)*10.0
   yfit = slatec_bvalu(xfit, fullbkpt, coeff)

 PROCEDURES CALLED:
   slatec_bvalu()
   slatec_efc()

 REVISION HISTORY:
   15-Oct-1999  Written by Scott Burles, Chicago
</PRE><P>
<STRONG>(See pro/slatec//slatec_splinefit.pro)</STRONG><P>
<HR>
 
<A NAME="SPLOT">
<H2>SPLOT</H2></A>
<A HREF="#SLATEC_SPLINEFIT">[Previous Routine]</A>
<A HREF="#STDEV">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   splot

 PURPOSE:
   Interactive plotting tool for 1-D (spectral) data.

 CALLING SEQUENCE:
   splot, [x], y, $
    [color=, psym=, symsize=, thick= ]

   soplot, [x], y, [/autoscale], $
    [color=, psym=, symsize=, thick= ]

   sxyouts, x, y, string, [alignment=, charsize=, charthick=, color=, $
    font=, orientation= ]

   serase, [nerase, /norefresh]

 INPUTS:

 OUTPUT:

 COMMENTS:
   This code is based upon Aaron Barth's ATV procedure.

 EXAMPLES:

 BUGS:
   Doesn't use the passed XRANGE, YRANGE properly yet...
   Move around widgets to be more compact above plotting window.
   Write splot_readfits.
   Make POSITION= changeable based upon CHARSIZE.
   Gaussian fitting or integrated gaussian fitting.
   Allow one to step through an image row at a time? Or link to ATV?
   Use the WCS in splot_gettrack.
   Add widget button option to fix Y range or let it float, or fix YMIN=0.
   Include options for plotting contours, etc?
   Options for XLOG, YLOG
   For FITS files, take XTITLE, YTITLE from header
   Option to pass header as param in SPLOT

 PROCEDURES CALLED:
   fits_read

 INTERNAL SUPPORT ROUTINES:
   splot_gausspix
   splot_startup
   splot_clearkeylist
   splot_displayall
   splot_readfits
   splot_writeeps
   splot_cleartext
   splot_zoom
   splot_gettrack
   splot_event
   splot_shutdown
   splot_resize
   splot_icolor()
   splot_setheader
   splot_headinfo
   splot_headinfo_event
   splot_plot1plot
   splot_plot1text
   splot_plotwindow
   splot_plotall
   sxyouts
   splot_move_cursor
   splot_set_minmax
   splot_get_minmax
   splot_refresh
   splot_help
   splot_help_event
   splot_plotparam_refresh
   splot_plotparam
   splot_plotparam_event
   serase
   splot_autoscale
   soplot
   splot

 REVISION HISTORY:
   28-Sep-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/plot//splot.pro)</STRONG><P>
<HR>
 
<A NAME="STDEV">
<H2>STDEV</H2></A>
<A HREF="#SPLOT">[Previous Routine]</A>
<A HREF="#STRUCT_ADDTAGS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
	STDEV

 PURPOSE:
	Compute the standard deviation and, optionally, the
	mean of any array.

 CATEGORY:
	G1- Simple calculations on statistical data.

 CALLING SEQUENCE:
	Result = STDEV(Array [, Mean])

 INPUTS:
	Array:	The data array.  Array may be any type except string.

 OUTPUTS:
	STDEV returns the standard deviation (sample variance
	because the divisor is N-1) of Array.
		
 OPTIONAL OUTPUT PARAMETERS:
	Mean:	Upon return, this parameter contains the mean of the values
		in the data array.

 COMMON BLOCKS:
	None.

 SIDE EFFECTS:
	None.

 RESTRICTIONS:
	None.

 PROCEDURE:
	Mean = TOTAL(Array)/N_ELEMENTS(Array)
	Stdev = SQRT(TOTAL((Array-Mean)^2/(N-1)))

 MODIFICATION HISTORY:
	DMS, RSI, Sept. 1983.
</PRE><P>
<STRONG>(See pro/math//stdev.pro)</STRONG><P>
<HR>
 
<A NAME="STRUCT_ADDTAGS">
<H2>STRUCT_ADDTAGS</H2></A>
<A HREF="#STDEV">[Previous Routine]</A>
<A HREF="#STRUCT_APPEND">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   struct_addtags

 PURPOSE:
   Add tags from one structure (array) to another

 CALLING SEQUENCE:
   outstruct = struct_addtags(astruct, bstruct)

 INPUTS:
   astruct    - First structure, which can be an array
   bstruct    - Second structure, which can be an array

 OPTIONAL INPUTS:

 OUTPUTS:
   outstruct  - Ouput structure array

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   28-Jun-2000  Written by D. Schlegel, Princeton
</PRE><P>
<STRONG>(See pro/misc//struct_addtags.pro)</STRONG><P>
<HR>
 
<A NAME="STRUCT_APPEND">
<H2>STRUCT_APPEND</H2></A>
<A HREF="#STRUCT_ADDTAGS">[Previous Routine]</A>
<A HREF="#STR_SEP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   struct_append

 PURPOSE:
   Append more array elements to a structure.

 CALLING SEQUENCE:
   outstruct = struct_append( struct1, struct2 )

 INPUTS:
   struct1    - First structure; the output structure will match the tags
                in this, and match the name if it's a named structure.
   struct2    - Second structure to append to the first.

 OPTIONAL INPUTS:

 OUTPUTS:

 OPTIONAL OUTPUTS:

 COMMENTS:
   If either structure is undefined, then return the other one only.

 EXAMPLES:
   &gt; a={one:1,two:2}
   &gt; b={one:11,three:33}
   &gt; print,struct_append(a,b)
     {       1       2}{      11       0}

 BUGS:

 PROCEDURES CALLED:
   headfits()

 REVISION HISTORY:
   26-Jun-2000  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/misc//struct_append.pro)</STRONG><P>
<HR>
 
<A NAME="STR_SEP">
<H2>STR_SEP</H2></A>
<A HREF="#STRUCT_APPEND">[Previous Routine]</A>
<A HREF="#TEXTOIDL[1]">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
    STR_SEP

 PURPOSE:
    This routine cuts a string into pieces which are separated by the 
    separator string.
 CATEGORY:
    String processing.
 CALLING SEQUENCE:
    arr = STR_SEP(str, separator)

 INPUTS:
    str - The string to be separated.
    separator - The separator.

 KEYWORDS:
    ESC = escape character.  Only valid if separator is a single character.
		Characters following the escape character are treated
		literally and not interpreted as separators.
		For example, if the separator is a comma,
		and the escape character is a backslash, the character
		sequence 'a\,b' is a single field containing the characters
		'a,b'.
    REMOVE_ALL = if set, remove all blanks from fields.
    TRIM = if set, remove only leading and trailing blanks from fields.

 OUTPUT: 
    An array of strings as function value.

 COMMON BLOCKS:
    None

 SIDE EFFECTS:
    No known side effects.

 RESTRICTIONS:
    None.

 EXAMPLE:
    array = STR_SEP (&quot;ulib.usca.test&quot;, &quot;.&quot;)

 MODIFICATION HISTORY:
	July 1992, AH,	CreaSo		Created.
	December, 1994, DMS, RSI	Added TRIM and REMOVE_ALL.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//str_sep.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL[1]">
<H2>TEXTOIDL[1]</H2></A>
<A HREF="#STR_SEP">[Previous Routine]</A>
<A HREF="#TEXTOIDL[2]">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 SPECIAL NOTE: 
       The file textoidl_trans_sub_super.pro contains two functions,
       textoidl_trans_sub_super, and textoidl_sub_sup.  The former is the
       generic routine for processing TeX sub/superscripts, the
       latter is used only by textoidl_trans_sub_super and has no general
       utility.  Hence it lives here.  You will see documentation for
       textoidl_trans_sub_super second if you use DOC_LIBRARY.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL[2]">
<H2>TEXTOIDL[2]</H2></A>
<A HREF="#TEXTOIDL[1]">[Previous Routine]</A>
<A HREF="#TEXTOIDL_MATCHDELIM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL
 PURPOSE:
       Convert a valid TeX string to a valid IDL string for plot labels.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       new = textoidl(old)
 INPUTS:
       old            -- TeX string to be converted.  Will not be     in
                         modified.  old may be a string array.
 KEYWORD PARAMETERS:
       FONT           -- Set to 0 to use hardware font, -1 to use 
                         vector.  Note that the only hardware font 
                         supported is PostScript.
       /TEX_SEQUENCES -- return the available TeX sequences
       /HELP          -- print out info on use of the function
                         and exit.
 OUTPUTS:
       new            -- IDL string corresponding to old.             out
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       - Use the procedure SHOWTEX to get a list of the available TeX
         control sequences.  
       - The only hardware font for which translation is available is
         PostScript. 
       - The only device for which hardware font'
         translation is available is PostScript.'
       - The FONT keyword overrides the font selected'
         by !p.font'
 EXAMPLE:
       out = TeXtoIDL('\Gamma^2 + 5N_{ed}')
       The string out may be used in XYOUTS or other IDL text
       display routines.  It will be an uppercase Gamma, with an
       exponent of 2, then a plus sign, then an N with the subscript
       ed.
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.4  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.3  1996/05/09 00:22:17  mcraig
       Added error handling, cleaned up documentation.

       Revision 1.2  1996/02/08 18:52:50  mcraig
       Added ability to use hardware fonts for PostScript device.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_MATCHDELIM">
<H2>TEXTOIDL_MATCHDELIM</H2></A>
<A HREF="#TEXTOIDL[2]">[Previous Routine]</A>
<A HREF="#TEXTOIDL_NEXTTOK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_MATCHDELIM
 PURPOSE:
        Match open/close delimiters in a string.
 CATEGORY:
        text/strings
 CALLING SEQUENCE:
        position = textoidl_matchdelim( strn, [openpos])
 INPUTS:
        strn        -- a string containing an open                 in
                       delimiter (e.g. '{') in which you 
                       want to find the matching closing  
                       delimiter (e.g. '}')
 KEYWORD PARAMETERS:
        OPEN_DELIM  -- A single character containing the opening   in
                       delimiter (e.g. '(').  Default is '{'
        CLOSE_DELIM -- A single character containing the closing   in
                       delimiter (e.g. ')').  Default is '}'
 OUTPUTS:
        position -- returns the position in strn of the            out
                    closing delimiter, -1 if no closing found.
        openpos  -- Set to a named variable to receive the         out
                    position of the first opening delimiter.
                    Optional.
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
        - Any pair of (nonidentical) characters can be used as
          delimiters. 
 EXAMPLE:
        textoidl_matchdelim('{one{two}}three') returns 9, the character just
        before 'three'.  
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.3  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.2  1996/05/09 00:22:17  mcraig
       Removed restriction that open delim must be first char.  Added argument
       to allow for return of position of open delim.

       Revision 1.1  1996/01/31 18:41:06  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_NEXTTOK">
<H2>TEXTOIDL_NEXTTOK</H2></A>
<A HREF="#TEXTOIDL_MATCHDELIM">[Previous Routine]</A>
<A HREF="#TEXTOIDL_STRCNT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_NEXTTOK
 PURPOSE:
       Find the next occurance of any of a set of characters in a
       string and return the character which occurs next.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       tok = textoidl_nexttok( strn, tokens )
 INPUTS:
       strn   -- string to be searched for sub/superscripts    in
       tokens -- string containing characters to be found.     in
 KEYWORD PARAMETERS:
       POSITION -- Set to a named variable to get position     out
                   of next token, or -1 if none found.
       /HELP    -- Print useful message and exit.
 OUTPUTS:
       tok    -- Contains the character among tokens which     out
                 occurs next in strn, or null '' if none found.
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
 EXAMPLE:
       textoidl_nexttok( 'x^2 + N_j^3', '^_', position=pos ) returns '^' and sets
       pos to 1.
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.3  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.2  1996/05/09 00:22:17  mcraig
       Generalized so that the next occurence of any of a set of characters will
       be returned.

       Revision 1.1  1996/01/31 18:41:06  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_STRCNT">
<H2>TEXTOIDL_STRCNT</H2></A>
<A HREF="#TEXTOIDL_NEXTTOK">[Previous Routine]</A>
<A HREF="#TEXTOIDL_STRTOK">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_STRCNT
 PURPOSE:
       Count number of occurrences of a substring in a string.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       num = textoidl_strcnt(strn, substring, [pos])
 INPUTS:
       string    -- The string in which to count occurences.     in
       substring -- The substring to count occurrences of.       in
       pos       -- the position at which to begin the search.   [in]
                    If not supplied, start at beginning of
                    string.
 KEYWORD PARAMETERS:
       /HELP     -- Print useful message and return.
 OUTPUTS:
       num       -- Number of occurances of substring in string. out
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       Overlapping occurances are not counted separately.  For
       example, counting occurances of 'bb' in 'blah bbb' returns one
       occurance. 
 EXAMPLE:
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.3  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.2  1996/05/09 00:22:17  mcraig
       Added fast processing using BYTE arrays if we are counting occurences of
       a single character.  Added error handling.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_STRTOK">
<H2>TEXTOIDL_STRTOK</H2></A>
<A HREF="#TEXTOIDL_STRCNT">[Previous Routine]</A>
<A HREF="#TEXTOIDL_STRTRANS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_STRTOK
 PURPOSE:
       Retrieve portion of string up to token.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       new = textoidl_strtok( old, token )
 INPUTS:
       old   -- String to be split.  Contains text after    in, out
                token on output.
       token -- Token to use in splitting old.              in
 KEYWORD PARAMETERS:
       /TRIM -- set to remove leading blanks from old 
                before returning.
       /HELP -- print useful message and exit.
 OUTPUTS:
       new   -- portion of string up to token.              out
       old   -- portion of old after token.                 out, in
 COMMON BLOCKS:
 SIDE EFFECTS:
       Input parameter old is modified.
 NOTES:
       Token may be one or more characters.
       If token is not found, returns old and sets old to ''.
 EXAMPLE:
       If old is 'foo44 bar', then textoidl_strtok( old, '44' ) would return
       'foo', and upon return, old will be left with ' bar'.  If /TRIM
       were set, old would be 'bar' on return.

       If old='xyz', then new=textoidl_strtok(old,'a') would return with
       new='xyz' and old=''.
 THANKS:
       To D. Linder who wrote GETTOK, part of the goddard library,
       upon which this is based.
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.3  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.2  1996/05/09 00:22:17  mcraig
       Added built in help.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_STRTRANS">
<H2>TEXTOIDL_STRTRANS</H2></A>
<A HREF="#TEXTOIDL_STRTOK">[Previous Routine]</A>
<A HREF="#TEXTOIDL_SUB_SUP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_STRTRANS
 PURPOSE:
       Translate all occurences of one substring to another.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       new = textoidl_strtrans(oldstr,from,to,ned)
 INPUTS:
       oldstr -- string on which to operate.              in
                 May be an array.
       from   -- substrings to be translated. May be      in
                 an array.
       to     -- what strings in from should be           in
                 translated to. May be an array.
 KEYWORD PARAMETERS:
       /HELP  -- Set this to print useful message and 
                 exit.
 OUTPUTS:
       new    -- Translated string. Array if oldstr is    out          
                 an array.
       ned    -- number of substitutions performed in     out
                 oldstr.  Array if oldstr is an array.
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       - Any of old, from, and to can be arrays.  
       - from and to must have the same number of elements.
 EXAMPLE:
       inp='Many*bad!chars+in_here'
       from=['*','!','+','_']
       to  =[' ',' ',' ',' ']
       out = textoidl_strtrans(inp,from,to,ned)
       Will produce out='Many bad chars in here', and set ned to 4.
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.3  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.2  1996/05/09 00:22:17  mcraig
       Sped up significantly by using str_sep to handle the translation.  No longer
       relies on routines fromother user libraries.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_SUB_SUP">
<H2>TEXTOIDL_SUB_SUP</H2></A>
<A HREF="#TEXTOIDL_STRTRANS">[Previous Routine]</A>
<A HREF="#TEXTOIDL_TABLE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_SUB_SUP
 PURPOSE:
       Return the proper IDL font positioning command for TeX
       sub/superscripts. 
 CATEGORY:
       TeXtoIDL
 CALLING SEQUENCE:
       fnt = textoidl_sub_sup( strn )
 INPUTS:
       strn      -- Either '^' or '_', the TeX super/subscript       in
                    characters
 KEYWORD PARAMETERS:
       /FORCE_UD -- Set this to use !U/!D instead of !E/!I for
                    sub/superscripts .
       /HELP     -- Set to print useful message and exit.
 OUTPUTS:
       fnt       -- Either '!U' or !E' for superscripts,             out
                    or '!D' or '!I' for subscripts.
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       Used only by textoidl_trans_sub_super.  Should be kept in same
       file. 
 EXAMPLE:
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.4  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.3  1996/05/09 00:22:17  mcraig
       Changed some function calls to reflect changes in those functions, moved
       some code out of the main loop that didn't need to be there, added
       documentation.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $
 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_TABLE">
<H2>TEXTOIDL_TABLE</H2></A>
<A HREF="#TEXTOIDL_SUB_SUP">[Previous Routine]</A>
<A HREF="#TEXTOIDL_TRANS_SUB_SUPER">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_TABLE
 PURPOSE:
       Returns a translation table from TeX to IDL.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       table = textoidl_table()
 INPUTS:
       None
 KEYWORD PARAMETERS:
       /POSTSCRIPT -- If set, return postscript translation
                      table rather than vector fonts table.
                      Default is translations for vector
                      fonts.
       /HELP       -- Print help and exit.
 OUTPUTS:
       table -- a 2D text array.  table(0,*) contains          out
                the words to be translated away, table(1,*)
                contains the words to translate them to.   
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       To find out what TeX sequences are available, look at
       table(0,*).
 EXAMPLE:
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.7  1996/07/22 23:56:08  mcraig
       Added \vartheta.

       Revision 1.6  1996/07/12 21:31:42  mcraig
       Fixed \varphi in vector font, added \circ.

       Revision 1.5  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.4  1996/05/09 00:22:17  mcraig
       Added command to return to previous font after switching to Greek or
       symbol font.

       Revision 1.3  1996/02/08 19:49:35  mcraig
       Removed control sequence \perp because the postscript code for it is '^'.

       Revision 1.2  1996/02/08 18:53:38  mcraig
       Added translations for PostScript fonts, and added several new TeX
       control sequences.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="TEXTOIDL_TRANS_SUB_SUPER">
<H2>TEXTOIDL_TRANS_SUB_SUPER</H2></A>
<A HREF="#TEXTOIDL_TABLE">[Previous Routine]</A>
<A HREF="#YANNY_FREE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       TEXTOIDL_TRANS_SUB_SUPER
 PURPOSE:
       Translate TeX sub/superscripts to IDL sub/superscripts.
 CATEGORY:
       text/strings
 CALLING SEQUENCE:
       new = textoidl_trans_sub_super( old )
 INPUTS:
       old       -- string to be translated from TeX to IDL.   in
 KEYWORD PARAMETERS:
       /RECURSED -- set if this function is being called 
                    recursively.                  
       /HELP     -- Set to print useful message and exit.
 OUTPUTS:
       new       -- string old converted from TeX to IDL       out
 COMMON BLOCKS:
 SIDE EFFECTS:
 NOTES:
       - For best results, when both a sub and superscript are used,
         place the shorter of the two first (e.g. 'N^{a}_{bbbb}' is
         better than 'N_{bbbb}^{a}').
       - Single character sub/super scripts do not need to be
         protected by braces.
       - Sub/superscripts may be nested (e.g. 'N^{N_1^N}').
 EXAMPLE:
       out = textoidl_trans_sub_super( 'N^2_{big}' )
       Then out='N!U2!N!Dbig!N' which looks like it should on the
       display. 
 LIBRARY FUNCTIONS CALLED:
       textoidl_strtok      -- Text/string (mcraig)
       textoidl_sub_sup -- contained in this file
 MODIFICATION HISTORY:
       $Id: idlutils_doc.html,v 1.1 2000-09-26 21:19:35 dfink Exp $
       $Log: not supported by cvs2svn $
       Revision 1.6  2000/07/12 14:31:33  hogg
       fixed another ()/[] bug.

       Revision 1.5  2000/06/15 18:21:23  hogg
       fixed tiny () -&gt; [] bugs

       Revision 1.4  2000/06/03 17:12:42  dfink
       Fink's new textoidl - all procedures in one file; avoid name conflict

       Revision 1.4  1996/06/14 20:00:27  mcraig
       Updated Copyright info.

       Revision 1.3  1996/05/09 00:22:17  mcraig
       Changed some function calls to reflect changes in those functions, moved
       some code out of the main loop that didn't need to be there, added
       documentation.

       Revision 1.2  1996/02/08 18:54:20  mcraig
       Changed default sub/superscript size to be !D/!U rather than !I/!E to
       improve readability of plat annotations.

       Revision 1.1  1996/01/31 18:47:37  mcraig
       Initial revision

 RELEASE:
       $Name: not supported by cvs2svn $

 COPYRIGHT:
  Copyright (C) 1996 The Regents of the University of California, All
  Rights Reserved.  Written by Matthew W. Craig.
  See the file COPYRIGHT for restrictions on distrubting this code.
  This code comes with absolutely NO warranty; see DISCLAIMER for details.
</PRE><P>
<STRONG>(See pro/TeXtoIDL//textoidl.pro)</STRONG><P>
<HR>
 
<A NAME="YANNY_FREE">
<H2>YANNY_FREE</H2></A>
<A HREF="#TEXTOIDL_TRANS_SUB_SUPER">[Previous Routine]</A>
<A HREF="#YANNY_PAR">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   yanny_free

 PURPOSE:
   Free memory allocated from reading a Yanny parameter file

 CALLING SEQUENCE:
   yanny_free, pdata

 INPUTS:
   pdata      - Array of pointers to all strucutures read by YANNY_READ.

 OPTIONAL INPUTS:

 OUTPUT:

 OPTIONAL OUTPUTS:

 COMMENTS:

 EXAMPLES:

 BUGS:

 PROCEDURES CALLED:

 REVISION HISTORY:
   15-Nov-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/yanny//yanny_free.pro)</STRONG><P>
<HR>
 
<A NAME="YANNY_PAR">
<H2>YANNY_PAR</H2></A>
<A HREF="#YANNY_FREE">[Previous Routine]</A>
<A HREF="#YANNY_READ">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   yanny_par

 PURPOSE:
   Obtain the value of a parameter in the header of a Yanny file.

 CALLING SEQUENCE:
   result = yanny_par( hdr, keyname, [count=count] )

 INPUTS:
   hdr        - Header lines in Yanny file, which are usually keyword pairs.
   keyname    - Keyword name of which to find its corresponding value

 OPTIONAL INPUTS:

 OUTPUT:
   result     - Value of parameter in header; return 0 if parameter not found

 OPTIONAL OUTPUTS:
   count      - Return the number of paramters found

 COMMENTS:
   This routine is meant to be analogous to the Goddard function SXPAR()
   for reading from FITS headers.

 EXAMPLES:

 BUGS:
   Wildcards are not supported for KEYNAME.

 PROCEDURES CALLED:

 INTERNAL SUPPORT ROUTINES:

 REVISION HISTORY:
   02-Nov-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/yanny//yanny_par.pro)</STRONG><P>
<HR>
 
<A NAME="YANNY_READ">
<H2>YANNY_READ</H2></A>
<A HREF="#YANNY_PAR">[Previous Routine]</A>
<A HREF="#YANNY_WRITE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   yanny_read

 PURPOSE:
   Read a Yanny parameter file into an IDL structure.

 CALLING SEQUENCE:
   yanny_read, filename, [ pdata, hdr=hdr, enums=enums, structs=structs, $
    /quick ]

 INPUTS:
   filename   - Input file name for Yanny parameter file

 OPTIONAL INPUTS:

 OUTPUT:

 OPTIONAL OUTPUTS:
   pdata      - Array of pointers to all structures read.  The i-th data
                structure is then referenced with &quot;*pdata[i]&quot;.  If you want
                to pass a single structure (eg, FOOBAR), then pass
                ptr_new(FOOBAR).
   hdr        - Header lines in Yanny file, which are usually keyword pairs.
   enums      - All &quot;typedef enum&quot; structures.
   structs    - All &quot;typedef struct&quot; structures, which define the form
                for all the PDATA structures.
   quick      - Quicker read using READF, but fails if continuation lines
                are present.

 COMMENTS:
   Read and write variables that are denoted INT in the Yanny file
   as IDL-type LONG, and LONG as IDL-type LONG64.  This is because
   Yanny files assume type INT is a 4-byte integer, whereas in IDL
   that type is only 2-byte.

 EXAMPLES:

 BUGS:
   The IDL procedure READF will fail if the last non-whitespace character
   is a backslash.  One can use such backslashes in Yanny files to indicate
   a continuation of that line onto the next.  For this reason, I wrote
   yanny_readstring as a replacement, though this will only work if all
   lines are &lt;= 255 characters.

   The reading could probably be sped up by setting a format string for
   each structure to use in the read.

   Not set up yet to deal with multi-dimensional arrays.

 PROCEDURES CALLED:
   mrd_struct

 INTERNAL SUPPORT ROUTINES:
   yanny_add_comment
   yanny_getwords()
   yanny_strip_brackets()
   yanny_strip_commas()
   yanny_readstring
   yanny_nextline()

 REVISION HISTORY:
   05-Sep-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/yanny//yanny_read.pro)</STRONG><P>
<HR>
 
<A NAME="YANNY_WRITE">
<H2>YANNY_WRITE</H2></A>
<A HREF="#YANNY_READ">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   yanny_write

 PURPOSE:
   Write a Yanny parameter file from an IDL structure.

 CALLING SEQUENCE:
   yanny_write, filename, [ pdata, hdr=hdr, enums=enums, structs=structs ]

 INPUTS:
   filename   - Output file name for Yanny parameter file

 OPTIONAL INPUTS:
   pdata      - Array of pointers to all structures write.  The i-th data
                structure is then referenced with &quot;*pdata[i]&quot;
   hdr        - Header lines in Yanny file, which are usually keyword pairs.
   enums      - All &quot;typedef enum&quot; structures.
   structs    - All &quot;typedef struct&quot; structures, which define the form
                for all the PDATA structures.

 OUTPUT:

 OPTIONAL OUTPUTS:

 COMMENTS:
   Read and write variables that are denoted INT in the Yanny file
   as IDL-type LONG, and LONG as IDL-type LONG64.  This is because
   Yanny files assume type INT is a 4-byte integer, whereas in IDL
   that type is only 2-byte.

 EXAMPLES:
   Read a Yanny parameter file, then re-write as a different file with:
     yanny_read, 'testin.par', pdata, comments=comments
     yanny_write, 'testout.par', pdata, comments=comments

 BUGS:
   There is no testing that STRUCTS is consistent with PDATA.

 PROCEDURES CALLED:

 REVISION HISTORY:
   05-Sep-1999  Written by David Schlegel, Princeton.
</PRE><P>
<STRONG>(See pro/yanny//yanny_write.pro)</STRONG><P>
<HR>
 
</body>
</html>
